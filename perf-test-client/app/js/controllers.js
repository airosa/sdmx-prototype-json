// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  demoModule.controller('MainCtrl', function($scope, $http) {
    var JSONCodeIndexCube, JSONSliceCube, bytesToSize, fixJsonCodeIndex, fixJsonSlice, getTestUrl, testCellAccess, testFlattenResults, testFlattenResultsWithReferences;
    $scope.version = '0.2.1';
    $scope.state = {
      httpError: false,
      httpErrorData: false,
      dataRequestRunning: false,
      dimensionRequestRunning: false
    };
    $scope.wsName = 'http://46.137.144.117/FusionMatrix/ws';
    $scope.dfName = 'SDMX,T1,1.0';
    $scope.key = 'M.0+1.0.0.0+1.1+2+3';
    $scope.customParams = '';
    $scope.dimensions = [];
    $scope.results = [];
    $scope.formats = ['jsoncodeindex', 'jsonslice'];
    fixJsonSlice = function(msg) {
      var comps, key, newTime, pkg, time, value, _ref;
      msg.structure.id = msg.structure.structure;
      delete msg.structure.structure;
      time = msg.structure.components.TIME_PERIOD;
      newTime = {
        id: time.id,
        name: time.name,
        role: 'time',
        values: []
      };
      for (key in time) {
        value = time[key];
        if (key !== 'id' && key !== 'name') {
          newTime.values.push(value);
        }
      }
      msg.structure.components.TIME_PERIOD = newTime;
      msg.structure.packaging = msg.structure.components.packaging;
      delete msg.structure.components.packaging;
      msg.structure.packaging.observationDimensions.push('TIME_PERIOD');
      pkg = msg.structure.packaging;
      comps = {};
      _ref = msg.structure.components;
      for (key in _ref) {
        value = _ref[key];
        comps[key] = value;
      }
      msg.structure = {
        dataSet: {
          dimensions: pkg.dataSetDimensions.map(function(id) {
            return comps[id];
          }),
          attributes: pkg.dataSetAttributes.map(function(id) {
            return comps[id];
          })
        },
        series: {
          dimensions: pkg.seriesDimensions.map(function(id) {
            return comps[id];
          }),
          attributes: pkg.seriesAttributes.map(function(id) {
            return comps[id];
          })
        },
        observation: {
          dimensions: pkg.observationDimensions.map(function(id) {
            return comps[id];
          }),
          attributes: pkg.observationAttributes.filter(function(id) {
            return comps[id] != null;
          }).map(function(id) {
            return comps[id];
          }),
          measures: []
        }
      };
      msg.structure.observation.measures.push({
        id: 'OBS_VALUE',
        name: 'Observation value',
        values: []
      });
      return msg;
    };
    fixJsonCodeIndex = function(msg) {
      var dim, _i, _len, _ref;
      msg.measures = [];
      msg.measures.push({
        id: 'OBS_VALUE',
        name: 'Observation value'
      });
      _ref = msg.dimensions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dim = _ref[_i];
        dim.values = dim.codes;
        delete dim.codes;
      }
      return msg;
    };
    $scope.testCrossfilter = function() {
      var dims, getFunction, groups, nameDim, sample, valueDim;
      sample = crossfilter([
        {
          name: 'Test1',
          value: 100
        }, {
          name: 'Test2',
          value: 200
        }, {
          name: 'Test3',
          value: 300
        }, {
          name: 'Test4',
          value: 400
        }, {
          name: 'Test4_2',
          value: 400
        }
      ]);
      nameDim = sample.dimension(function(d) {
        return d.name;
      });
      valueDim = sample.dimension(function(d) {
        return d.value;
      });
      sample = crossfilter([['Test1', 100], ['Test2', 200], ['Test3', 300], ['Test4', 400], ['Test4_2', 400]]);
      getFunction = function(id) {
        return function(d) {
          return d[id];
        };
      };
      dims = [];
      dims.push(sample.dimension(getFunction(0)));
      dims.push(sample.dimension(getFunction(1)));
      groups = [];
      groups.push(dims[0].group());
      groups.push(dims[1].group());
      $scope.crossFilterOutput = [];
      $scope.crossFilterOutput.push({
        name: 'size',
        value: sample.size()
      });
      $scope.crossFilterOutput.push({
        name: 'top value',
        value: dims[1].top(1)[0][1]
      });
      dims[0].filter('Test2');
      $scope.crossFilterOutput.push({
        name: 'value for Test2',
        value: dims[1].top(1)[0][1]
      });
      dims[1].filter(400);
      $scope.crossFilterOutput.push({
        name: 'filter count',
        value: dims[1].top(Infinity).length
      });
      dims[0].filter('Test4');
      $scope.crossFilterOutput.push({
        name: 'filter count',
        value: dims[1].top(Infinity).length
      });
      $scope.crossFilterOutput.push({
        name: 'group[0] size',
        value: groups[0].size()
      });
      return $scope.crossFilterOutput.push({
        name: 'group[1] size',
        value: groups[1].size()
      });
    };
    $scope.getDimensions = function() {
      var config, onError, onResults;
      onError = function(data, status, headers, config) {
        $scope.state.testRunning = false;
        $scope.state.httpError = true;
        return $scope.response = {
          status: status,
          errors: data.errors
        };
      };
      onResults = function(data, status, headers, config) {
        var codes, componentMap, dim, dimId, dims, pkg, value, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _results;
        $scope.state.testRunning = false;
        $scope.state.httpError = false;
        data = fixJsonSlice(data);
        pkg = data.structure.packaging;
        if ((_ref = pkg.dataSetDimensions) == null) {
          pkg.dataSetDimensions = [];
        }
        if ((_ref1 = pkg.seriesDimensions) == null) {
          pkg.seriesDimensions = [];
        }
        if ((_ref2 = pkg.observationDimensions) == null) {
          pkg.observationDimensions = [];
        }
        dims = pkg.dataSetDimensions.concat(pkg.seriesDimensions, pkg.observationDimensions);
        componentMap = {};
        data.structure.components.forEach(function(c) {
          return componentMap[c.id] = c;
        });
        $scope.dimensions = [];
        _results = [];
        for (_i = 0, _len = dims.length; _i < _len; _i++) {
          dimId = dims[_i];
          dim = componentMap[dimId];
          codes = [];
          _ref3 = dim.values;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            value = _ref3[_j];
            codes.push(value.id);
          }
          _results.push($scope.dimensions.push({
            id: dimId,
            name: dim.name,
            codes: codes.join(', ')
          }));
        }
        return _results;
      };
      config = {
        method: 'GET',
        url: "" + $scope.wsName + "/data/" + $scope.dfName + "/ALL?format=jsonslice&detail=seriesKeysOnly",
        cache: false
      };
      $scope.state.httpError = false;
      $scope.state.testRunning = true;
      return $http(config).success(onResults).error(onError);
    };
    $scope.runTest = function(format) {
      var config, onError, onResults, result, start, startMem, transformResponse, _ref;
      start = (new Date).getTime();
      if ((typeof window !== "undefined" && window !== null ? (_ref = window.performance) != null ? _ref.memory : void 0 : void 0) != null) {
        startMem = window.performance.memory.usedJSHeapSize;
      }
      result = {
        format: format
      };
      $scope.results.push(result);
      transformResponse = function(data) {
        return data;
      };
      onResults = function(data, status, headers, config) {
        var cube, json, _ref1;
        $scope.state.testRunning = false;
        $scope.state.httpError = false;
        $scope.response = {
          status: status
        };
        result.requestTime = ((new Date).getTime() - start) + ' ms';
        result.responseSize = bytesToSize(unescape(encodeURIComponent(data.length)), 2);
        start = (new Date).getTime();
        json = JSON.parse(data);
        result.parseTime = ((new Date).getTime() - start) + ' ms';
        if ((typeof window !== "undefined" && window !== null ? (_ref1 = window.performance) != null ? _ref1.memory : void 0 : void 0) != null) {
          result.memory = window.performance.memory.usedJSHeapSize - startMem;
        }
        start = (new Date).getTime();
        cube = (function() {
          switch (result.format) {
            case 'jsonslice':
              return new JSONSliceCube(json);
            case 'jsoncodeindex':
              return new JSONCodeIndexCube(json, false, true);
          }
        })();
        result.initTime = ((new Date).getTime() - start) + ' ms';
        result.actualObsCount = cube.obsCount();
        result.dataChecksum = cube.checkSum();
        start = (new Date).getTime();
        result.simpleArrayChecksum = testFlattenResults(cube, result);
        result.flattenToSimpleArray = ((new Date).getTime() - start) + ' ms';
        start = (new Date).getTime();
        result.complexArrayChecksum = testFlattenResultsWithReferences(cube, result);
        result.flattenToComplexArray = ((new Date).getTime() - start) + ' ms';
        start = (new Date).getTime();
        result.cellAccessChecksum = testCellAccess(cube, result);
        return result.cellAccess = ((new Date).getTime() - start) + ' ms';
      };
      onError = function(data, status, headers, config) {
        $scope.state.testRunning = false;
        $scope.state.httpError = true;
        return $scope.response = {
          status: status,
          errors: data.errors
        };
      };
      config = {
        method: 'GET',
        url: getTestUrl(format),
        transformResponse: transformResponse,
        cache: false
      };
      $scope.state.httpError = false;
      $scope.state.testRunning = true;
      return $http(config).success(onResults).error(onError);
    };
    JSONSliceCube = (function() {

      function JSONSliceCube(msg) {
        this.msg = msg;
        this.components = __bind(this.components, this);

        this.observationsWithReferences = __bind(this.observationsWithReferences, this);

        this.observations = __bind(this.observations, this);

        this.msg = fixJsonSlice(this.msg);
      }

      JSONSliceCube.prototype.observations = function() {
        var ds, o, obs, s, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
        obs = [];
        _ref = this.msg.dataSets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ds = _ref[_i];
          if ((_ref1 = ds.dimensions) == null) {
            ds.dimensions = [];
          }
          if (ds.observations != null) {
            _ref2 = ds.observations;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              o = _ref2[_j];
              obs.push(ds.dimensions.concat(o));
            }
          } else {
            _ref3 = ds.series;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              s = _ref3[_k];
              _ref4 = s.observations;
              for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                o = _ref4[_l];
                obs.push(ds.dimensions.concat(s.dimensions, o));
              }
            }
          }
        }
        return obs;
      };

      JSONSliceCube.prototype.observationsWithReferences = function() {
        var ds, dsDimMap, i, o, obs, s, serMap, str, t, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        str = this.msg.structure;
        obs = [];
        _ref = this.msg.dataSets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ds = _ref[_i];
          if ((_ref1 = ds.dimensions) == null) {
            ds.dimensions = [];
          }
          dsDimMap = ds.dimensions.map(function(v, i) {
            return str.dataSet.dimensions[i].values[v];
          });
          if (ds.observations != null) {
            _ref2 = ds.observations;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              o = _ref2[_j];
              obs.push(dsDimMap.concat(o));
            }
          } else {
            _ref3 = ds.series;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              s = _ref3[_k];
              serMap = s.dimensions.map(function(v, i) {
                return str.series.dimensions[i].values[v];
              });
              _ref4 = s.observations;
              for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                o = _ref4[_l];
                t = [];
                _ref5 = str.observation.dimensions;
                for (i = _m = 0, _len4 = _ref5.length; _m < _len4; i = ++_m) {
                  v = _ref5[i];
                  t[i] = str.observation.dimensions[i].values[o[i]];
                }
                t.push(o[str.observation.dimensions.length]);
                obs.push(dsDimMap.concat(serMap, t));
              }
            }
          }
        }
        return obs;
      };

      JSONSliceCube.prototype.components = function() {
        var str;
        str = this.msg.structure;
        return str.dataSet.dimensions.concat(str.series.dimensions, str.observation.dimensions, str.observation.measures, str.observation.attributes);
      };

      JSONSliceCube.prototype.dimensions = function() {
        var str;
        str = this.msg.structure;
        return str.dataSet.dimensions.concat(str.series.dimensions, str.observation.dimensions);
      };

      JSONSliceCube.prototype.observation = function(key) {
        var dDims, ds, o, oDims, obs, s, sDims, series, str, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        if (this.index != null) {
          return this.index[key.join(':')];
        }
        this.index = {};
        oDims = this.msg.structure.observation.dimensions.length;
        _ref = this.msg.dataSets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ds = _ref[_i];
          if (ds.observations != null) {
            _ref1 = ds.observations;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              o = _ref1[_j];
              this.index[ds.dimensions.concat(o.slice(0, oDims)).join(':')] = o[oDims];
            }
          } else {
            _ref2 = ds.series;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              s = _ref2[_k];
              _ref3 = s.observations;
              for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                o = _ref3[_l];
                this.index[ds.dimensions.concat(s.dimensions, o.slice(0, oDims)).join(':')] = o[oDims];
              }
            }
          }
        }
        if (this.index != null) {
          return this.index[key.join(':')];
        }
        str = this.msg.structure;
        dDims = key.slice(0, str.dataSet.dimensions.length);
        sDims = key.slice(dDims.length, dDims.length + str.series.dimensions.length);
        oDims = key.slice(dDims.length + sDims.length);
        _ref4 = this.msg.dataSets;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          ds = _ref4[_m];
          if (!ds.dimensions.every(function(d, i) {
            return d === dDims[i];
          })) {
            continue;
          }
          if (ds.observations != null) {

          } else {
            _ref5 = ds.series;
            for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
              series = _ref5[_n];
              if (!series.dimensions.every(function(d, i) {
                return d === sDims[i];
              })) {
                continue;
              }
              _ref6 = series.observations;
              for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
                obs = _ref6[_o];
                if (!oDims.every(function(d, i) {
                  return d === obs[i];
                })) {
                  continue;
                }
                return obs[oDims.length];
              }
            }
          }
        }
        return null;
      };

      JSONSliceCube.prototype.obsCount = function() {
        var reduceDataSets, reduceSeries;
        reduceSeries = function(t, s) {
          return t + s.observations.length;
        };
        reduceDataSets = function(t, d) {
          if (d.observations != null) {
            return t + d.observations.reduce(reduceObservations, 0);
          } else {
            return t + d.series.reduce(reduceSeries, 0);
          }
        };
        return this.msg.dataSets.reduce(reduceDataSets, 0);
      };

      JSONSliceCube.prototype.checkSum = function() {
        var obsValueIndex, reduceDataSets, reduceObservations, reduceSeries,
          _this = this;
        obsValueIndex = this.msg.structure.observation.dimensions.length;
        reduceObservations = function(t, o) {
          var value;
          value = o[obsValueIndex];
          if (value != null) {
            return t + value;
          } else {
            return t;
          }
        };
        reduceSeries = function(t, s) {
          return t + s.observations.reduce(reduceObservations, 0);
        };
        reduceDataSets = function(t, d) {
          if (d.observations != null) {
            return t + d.observations.reduce(reduceObservations, 0);
          } else {
            return t + d.series.reduce(reduceSeries, 0);
          }
        };
        return this.msg.dataSets.reduce(reduceDataSets, 0);
      };

      return JSONSliceCube;

    })();
    JSONCodeIndexCube = (function() {

      function JSONCodeIndexCube(msg) {
        this.msg = msg;
        this.msg = fixJsonCodeIndex(this.msg);
      }

      JSONCodeIndexCube.prototype.observations = function() {
        var dims, key, obs, _i, _len, _ref;
        obs = [];
        _ref = Object.keys(this.msg.data);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          dims = key.split(':');
          dims.push(this.msg.data[key]);
          obs.push(dims);
        }
        return obs;
      };

      JSONCodeIndexCube.prototype.observationsWithReferences = function() {
        var i, key, o, obs, v, _i, _j, _len, _len1, _ref, _ref1;
        obs = [];
        _ref = Object.keys(this.msg.data);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          o = [];
          _ref1 = key.split(':');
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            v = _ref1[i];
            o.push(this.msg.dimensions[i].values[v]);
          }
          o.push(this.msg.data[key]);
          obs.push(o);
        }
        return obs;
      };

      JSONCodeIndexCube.prototype.components = function() {
        return this.msg.dimensions.concat(this.msg.measures);
      };

      JSONCodeIndexCube.prototype.dimensions = function() {
        return this.msg.dimensions.slice();
      };

      JSONCodeIndexCube.prototype.observation = function(key) {
        return this.msg.data[key.join(':')];
      };

      JSONCodeIndexCube.prototype.checkSum = function() {
        var key, sum, _i, _len, _ref;
        sum = 0;
        _ref = Object.keys(this.msg.data);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          sum += this.msg.data[key];
        }
        return sum;
      };

      JSONCodeIndexCube.prototype.obsCount = function() {
        return Object.keys(this.msg.data).length;
      };

      return JSONCodeIndexCube;

    })();
    testFlattenResults = function(cube, result) {
      var c, checkSum, components, i, obs, obsValueIndex, _i, _len;
      components = cube.components();
      obsValueIndex = -1;
      components.forEach(function(c, i) {
        if (c.id === 'OBS_VALUE') {
          return obsValueIndex = i;
        }
      });
      result.obsCount = 1;
      for (i = _i = 0, _len = components.length; _i < _len; i = ++_i) {
        c = components[i];
        if (i < obsValueIndex) {
          result.obsCount *= c.values.length;
        }
      }
      obs = cube.observations();
      result.simpleArrayLength = obs.length;
      checkSum = obs.reduce((function(i, o) {
        return i + o[obsValueIndex];
      }), 0);
      result.density = (result.actualObsCount / result.obsCount).toFixed(2);
      return checkSum;
    };
    testFlattenResultsWithReferences = function(cube, result) {
      var c, checkSum, components, i, obs, obsValueIndex, _i, _len;
      components = cube.components();
      obsValueIndex = -1;
      components.forEach(function(c, i) {
        if (c.id === 'OBS_VALUE') {
          return obsValueIndex = i;
        }
      });
      result.obsCount = 1;
      for (i = _i = 0, _len = components.length; _i < _len; i = ++_i) {
        c = components[i];
        if (i < obsValueIndex) {
          result.obsCount *= c.values.length;
        }
      }
      obs = cube.observationsWithReferences();
      result.complexArrayLength = obs.length;
      checkSum = obs.reduce((function(i, o) {
        return i + o[obsValueIndex];
      }), 0);
      return checkSum;
    };
    testCellAccess = function(cube, result) {
      var checkSum, codeLengths, dim, dimensions, i, j, key, length, missing, multipliers, obs, obsCount, prev, _i, _j, _k, _len, _len1, _ref, _ref1;
      dimensions = cube.dimensions();
      obsCount = 1;
      multipliers = [];
      codeLengths = [];
      prev = 1;
      _ref = dimensions.slice().reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dim = _ref[_i];
        multipliers.push(prev);
        obsCount *= dim.values.length;
        codeLengths.push(dim.values.length);
        prev *= dim.values.length;
      }
      multipliers.reverse();
      codeLengths.reverse();
      checkSum = 0;
      missing = 0;
      for (i = _j = 0, _ref1 = obsCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        key = [];
        for (j = _k = 0, _len1 = codeLengths.length; _k < _len1; j = ++_k) {
          length = codeLengths[j];
          key.push(Math.floor(i / multipliers[j]) % length);
        }
        obs = cube.observation(key);
        if (!(obs != null)) {
          missing += 1;
          continue;
        }
        checkSum += obs;
      }
      return checkSum;
    };
    bytesToSize = function(bytes, precision) {
      var gigabyte, kilobyte, megabyte, terabyte;
      kilobyte = 1024;
      megabyte = kilobyte * 1024;
      gigabyte = megabyte * 1024;
      terabyte = gigabyte * 1024;
      if (bytes >= 0 && bytes < kilobyte) {
        return bytes + ' B';
      } else if (bytes >= kilobyte && bytes < megabyte) {
        return (bytes / kilobyte).toFixed(precision) + ' KB';
      } else if (bytes >= megabyte && bytes < gigabyte) {
        return (bytes / megabyte).toFixed(precision) + ' MB';
      } else if (bytes >= gigabyte && bytes < terabyte) {
        return (bytes / gigabyte).toFixed(precision) + ' GB';
      } else if (bytes >= terabyte) {
        return (bytes / terabyte).toFixed(precision) + ' TB';
      } else {
        return bytes + ' B';
      }
    };
    getTestUrl = function(format) {
      var params, testUrl;
      testUrl = "" + $scope.wsName + "/data/" + $scope.dfName;
      if ($scope.key.length) {
        testUrl += "/" + $scope.key;
      }
      params = [];
      if ($scope.customParams.length) {
        params.push($scope.customParams);
      }
      params.push('format=' + format.split('_')[0]);
      if (params.length) {
        testUrl += "?" + params.join('&');
      }
      $scope.url = testUrl;
      return testUrl;
    };
  });

}).call(this);
