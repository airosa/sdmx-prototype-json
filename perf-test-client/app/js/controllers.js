// Generated by CoffeeScript 1.3.3
(function() {

  demoModule.controller('MainCtrl', function($scope, $http) {
    var JSONArrayCube, JSONIndexCube, JSONSeries2Cube, JSONSeriesCube, bytesToSize, format, getTestUrl, result, testCube, testTimeSeries, _i, _len, _ref;
    $scope.version = '0.1.1';
    $scope.state = {
      httpError: false,
      httpErrorData: false,
      dataRequestRunning: false,
      dimensionRequestRunning: false
    };
    $scope.wsName = 'http://46.137.144.117/FusionCube/ws';
    $scope.dfName = 'BIS,BISWEB_EERDATAFLOW,1.0';
    $scope.key = '....';
    $scope.customParams = '';
    $scope.customParams = 'outputdates=true';
    $scope.results = [];
    _ref = ['jsonseries', 'jsonseries2', 'jsonindex', 'jsonarray'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      format = _ref[_i];
      result = {
        format: format
      };
      $scope.results.push(result);
    }
    $scope.runTest = function(index) {
      var config, onError, onResults, start, startMem, transformResponse, _ref1;
      start = (new Date).getTime();
      if ((typeof window !== "undefined" && window !== null ? (_ref1 = window.performance) != null ? _ref1.memory : void 0 : void 0) != null) {
        startMem = window.performance.memory;
      }
      transformResponse = function(data) {
        return data;
      };
      onResults = function(data, status, headers, config) {
        var calibration, cube, json, stringKey, _ref2;
        result = $scope.results[index];
        $scope.state.testRunning = false;
        $scope.state.httpError = false;
        $scope.response = {
          status: status
        };
        result.requestTime = ((new Date).getTime() - start) + ' ms';
        result.size = bytesToSize(unescape(encodeURIComponent(data.length)), 2);
        start = (new Date).getTime();
        json = JSON.parse(data);
        if ((typeof window !== "undefined" && window !== null ? (_ref2 = window.performance) != null ? _ref2.memory : void 0 : void 0) != null) {
          result.memory = window.performance.memory - startMem;
        }
        cube = (function() {
          switch (result.format) {
            case 'jsonarray':
              return new JSONArrayCube(json);
            case 'jsonindex':
              return new JSONIndexCube(json);
            case 'jsonseries':
              return new JSONSeriesCube(json);
            case 'jsonseries2':
              return new JSONSeries2Cube(json);
          }
        })();
        stringKey = (function() {
          switch (result.format) {
            case 'jsonarray':
            case 'jsonindex':
              return false;
            default:
              return true;
          }
        })();
        result.parseTime = ((new Date).getTime() - start) + ' ms';
        start = (new Date).getTime();
        testCube(cube, result, true, stringKey);
        calibration = (new Date).getTime() - start;
        start = (new Date).getTime();
        result.cubeChecksum = testCube(cube, result, false, stringKey);
        result.cubeAccessTime = ((new Date).getTime() - start - calibration) + ' ms';
        start = (new Date).getTime();
        testTimeSeries(cube, result, true, stringKey);
        calibration = (new Date).getTime() - start;
        start = (new Date).getTime();
        result.tsChecksum = testTimeSeries(cube, result, false, stringKey);
        return result.tsAccessTime = ((new Date).getTime() - start - calibration) + ' ms';
      };
      onError = function(data, status, headers, config) {
        $scope.state.testRunning = false;
        $scope.state.httpError = true;
        return $scope.response = {
          status: status,
          errors: data.errors
        };
      };
      $scope.results[index] = {
        format: $scope.results[index].format
      };
      config = {
        method: 'GET',
        url: getTestUrl($scope.results[index].format),
        transformResponse: transformResponse,
        cache: false
      };
      $scope.state.httpError = false;
      $scope.state.testRunning = true;
      return $http(config).success(onResults).error(onError);
    };
    JSONArrayCube = (function() {

      function JSONArrayCube(msg) {
        var dimId, dims, prev, _j, _len1, _ref1;
        this.msg = msg;
        this.multipliers = [];
        prev = 1;
        _ref1 = this.dimensions().reverse();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dimId = _ref1[_j];
          this.multipliers.push(prev);
          prev *= this.codes(dimId).length;
        }
        this.multipliers.reverse();
        dims = this.dimensions();
        this.timeDimensionCodes = this.codes(dims[dims.length - 1]);
      }

      JSONArrayCube.prototype.dimensions = function() {
        var dims;
        dims = this.msg.dimensions.id.slice();
        dims.push('TIME_PERIOD');
        return dims;
      };

      JSONArrayCube.prototype.codes = function(dimension) {
        return this.msg.dimensions[dimension].codes.id.slice();
      };

      JSONArrayCube.prototype.observation = function(key) {
        var codeIndex, index, j, _j, _len1, _ref1;
        index = 0;
        for (j = _j = 0, _len1 = key.length; _j < _len1; j = ++_j) {
          codeIndex = key[j];
          index += codeIndex * this.multipliers[j];
        }
        if (((_ref1 = this.msg.measure[0]) != null ? _ref1[index] : void 0) == null) {
          return void 0;
        }
        return +this.msg.measure[0][index];
      };

      JSONArrayCube.prototype.timeSeries = function(key) {
        var i, last, obs, series, timePeriod, _j, _len1, _ref1;
        series = {
          observations: []
        };
        last = key.length;
        _ref1 = this.timeDimensionCodes;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          timePeriod = _ref1[i];
          key[last] = i;
          obs = this.observation(key);
          if (obs == null) {
            continue;
          }
          series.observations.push({
            value: obs
          });
        }
        return series;
      };

      return JSONArrayCube;

    })();
    JSONIndexCube = (function() {

      function JSONIndexCube(msg) {
        var dimId, dims, prev, _j, _len1, _ref1;
        this.msg = msg;
        this.multipliers = [];
        prev = 1;
        _ref1 = this.dimensions().reverse();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dimId = _ref1[_j];
          this.multipliers.push(prev);
          prev *= this.codes(dimId).length;
        }
        this.multipliers.reverse();
        dims = this.dimensions();
        this.timeDimensionCodes = this.codes(dims[dims.length - 1]);
      }

      JSONIndexCube.prototype.dimensions = function() {
        return this.msg.dimensions.id.slice();
      };

      JSONIndexCube.prototype.codes = function(dimension) {
        return this.msg.dimensions[dimension].codes.slice();
      };

      JSONIndexCube.prototype.observation = function(key) {
        var codeIndex, index, j, _j, _len1, _ref1;
        index = 0;
        for (j = _j = 0, _len1 = key.length; _j < _len1; j = ++_j) {
          codeIndex = key[j];
          index += codeIndex * this.multipliers[j];
        }
        return (_ref1 = this.msg.measure[index]) != null ? _ref1[0] : void 0;
      };

      JSONIndexCube.prototype.timeSeries = function(key) {
        var i, last, obs, series, timePeriod, _j, _len1, _ref1;
        series = {
          observations: []
        };
        last = key.length;
        _ref1 = this.timeDimensionCodes;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          timePeriod = _ref1[i];
          key[last] = i;
          obs = this.observation(key);
          if (obs == null) {
            continue;
          }
          series.observations.push({
            value: obs
          });
        }
        return series;
      };

      return JSONIndexCube;

    })();
    JSONSeriesCube = (function() {

      function JSONSeriesCube(msg) {
        var dimId, _j, _len1, _ref1;
        this.msg = msg;
        this.dimCodes = [];
        _ref1 = this.dimensions();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dimId = _ref1[_j];
          this.dimCodes.push(this.codes(dimId));
        }
      }

      JSONSeriesCube.prototype.dimensions = function() {
        return this.msg.dimensions.id.slice();
      };

      JSONSeriesCube.prototype.codes = function(dimension) {
        return Object.keys(this.msg.dimensions[dimension].codes);
      };

      JSONSeriesCube.prototype.observation = function(key) {
        var keyString, obs, timePeriod, _ref1, _ref2;
        timePeriod = key[key.length - 1];
        keyString = key.slice(0, -1).join(':');
        obs = (_ref1 = this.msg.measure[keyString]) != null ? (_ref2 = _ref1.observations[timePeriod]) != null ? _ref2[0] : void 0 : void 0;
        if (obs != null) {
          return +obs;
        } else {
          return void 0;
        }
      };

      JSONSeriesCube.prototype.timeSeries = function(key) {
        var keyString, newSeries, obs, series, timePeriod, _j, _len1, _ref1;
        keyString = key.join(':');
        newSeries = {
          observations: []
        };
        series = this.msg.measure[keyString];
        if (series == null) {
          return newSeries;
        }
        _ref1 = Object.keys(series.observations);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          timePeriod = _ref1[_j];
          obs = series.observations[timePeriod];
          if (obs == null) {
            continue;
          }
          newSeries.observations.push({
            value: +obs[0]
          });
        }
        return newSeries;
      };

      return JSONSeriesCube;

    })();
    JSONSeries2Cube = (function() {

      function JSONSeries2Cube(msg) {
        var dimId, _j, _len1, _ref1;
        this.msg = msg;
        this.dimCodes = [];
        _ref1 = this.dimensions();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dimId = _ref1[_j];
          this.dimCodes.push(this.codes(dimId));
        }
      }

      JSONSeries2Cube.prototype.dimensions = function() {
        return Object.keys(this.msg.dimensions);
      };

      JSONSeries2Cube.prototype.codes = function(dimension) {
        return Object.keys(this.msg.dimensions[dimension].codes);
      };

      JSONSeries2Cube.prototype.observation = function(key) {
        var keyString, obs, obsIndex, timePeriod, _ref1, _ref2;
        timePeriod = key[key.length - 1];
        keyString = key.slice(0, -1).join(':');
        obsIndex = (_ref1 = this.msg.measure[keyString]) != null ? (_ref2 = _ref1.observations) != null ? _ref2.TIME_PERIOD.indexOf(timePeriod) : void 0 : void 0;
        if (!((obsIndex != null) && -1 < obsIndex)) {
          return void 0;
        }
        obs = this.msg.measure[keyString].observations.values[obsIndex];
        if (obs != null) {
          return +obs;
        } else {
          return void 0;
        }
      };

      JSONSeries2Cube.prototype.timeSeries = function(key) {
        var keyString, newSeries, obs, series, _j, _len1, _ref1;
        keyString = key.join(':');
        newSeries = {
          observations: []
        };
        series = this.msg.measure[keyString];
        if (series == null) {
          return newSeries;
        }
        _ref1 = series.observations.values;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          obs = _ref1[_j];
          if (obs == null) {
            continue;
          }
          newSeries.observations.push({
            value: +obs
          });
        }
        return newSeries;
      };

      return JSONSeries2Cube;

    })();
    testCube = function(cube, result, calibrate, stringKey) {
      var checkSum, codeIndex, codeLengths, codePos, codes, dimCodes, dimId, dimensions, i, j, key, length, missing, multipliers, obs, obsCount, prev, _j, _k, _l, _len1, _len2, _len3, _m, _ref1, _ref2;
      dimensions = cube.dimensions();
      codes = [];
      obsCount = 1;
      multipliers = [];
      codeLengths = [];
      prev = 1;
      _ref1 = dimensions.slice().reverse();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        dimId = _ref1[_j];
        multipliers.push(prev);
        dimCodes = cube.codes(dimId);
        codes.push(dimCodes);
        obsCount *= dimCodes.length;
        codeLengths.push(dimCodes.length);
        prev *= dimCodes.length;
      }
      multipliers.reverse();
      codeLengths.reverse();
      codes.reverse();
      result.obsCount = obsCount;
      checkSum = 0;
      missing = 0;
      for (i = _k = 0, _ref2 = obsCount - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        key = [];
        for (j = _l = 0, _len2 = codeLengths.length; _l < _len2; j = ++_l) {
          length = codeLengths[j];
          codeIndex = Math.floor(i / multipliers[j]) % length;
          key.push(codeIndex);
        }
        if (stringKey) {
          for (j = _m = 0, _len3 = key.length; _m < _len3; j = ++_m) {
            codePos = key[j];
            key[j] = codes[j][codePos];
          }
        }
        if (!calibrate) {
          obs = cube.observation(key);
        }
        if (!(obs != null)) {
          missing += 1;
          continue;
        }
        checkSum += obs;
      }
      result.density = (1 - (missing / obsCount)).toFixed(2);
      return checkSum;
    };
    testTimeSeries = function(cube, result, calibrate, stringKey) {
      var checkSum, codeIndex, codeLengths, codePos, codes, dimCodes, dimId, dimensions, i, j, key, length, multipliers, obs, prev, series, seriesCount, startMem, timeSeries, _j, _k, _l, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref1, _ref2, _ref3, _ref4, _ref5;
      if ((typeof window !== "undefined" && window !== null ? (_ref1 = window.performance) != null ? _ref1.memory : void 0 : void 0) != null) {
        startMem = window.performance.memory;
      }
      timeSeries = [];
      dimensions = cube.dimensions();
      dimensions.pop();
      seriesCount = 1;
      multipliers = [];
      codeLengths = [];
      codes = [];
      prev = 1;
      _ref2 = dimensions.reverse();
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        dimId = _ref2[_j];
        multipliers.push(prev);
        dimCodes = cube.codes(dimId);
        codes.push(dimCodes);
        seriesCount *= dimCodes.length;
        codeLengths.push(dimCodes.length);
        prev *= dimCodes.length;
      }
      multipliers.reverse();
      codeLengths.reverse();
      codes.reverse();
      result.tsCount = seriesCount;
      checkSum = 0;
      for (i = _k = 0, _ref3 = seriesCount - 1; 0 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
        key = [];
        for (j = _l = 0, _len2 = codeLengths.length; _l < _len2; j = ++_l) {
          length = codeLengths[j];
          codeIndex = Math.floor(i / multipliers[j]) % length;
          key.push(codeIndex);
        }
        if (stringKey) {
          for (j = _m = 0, _len3 = key.length; _m < _len3; j = ++_m) {
            codePos = key[j];
            key[j] = codes[j][codePos];
          }
        }
        if (!calibrate) {
          series = cube.timeSeries(key);
        }
        if (series == null) {
          continue;
        }
        timeSeries.push(series);
      }
      for (_n = 0, _len4 = timeSeries.length; _n < _len4; _n++) {
        series = timeSeries[_n];
        _ref4 = series.observations;
        for (_o = 0, _len5 = _ref4.length; _o < _len5; _o++) {
          obs = _ref4[_o];
          if (obs.value == null) {
            continue;
          }
          checkSum += obs.value;
        }
      }
      if ((typeof window !== "undefined" && window !== null ? (_ref5 = window.performance) != null ? _ref5.memory : void 0 : void 0) != null) {
        result.tsMemory = window.performance.memory - startMem;
      }
      return checkSum;
    };
    bytesToSize = function(bytes, precision) {
      var gigabyte, kilobyte, megabyte, terabyte;
      kilobyte = 1024;
      megabyte = kilobyte * 1024;
      gigabyte = megabyte * 1024;
      terabyte = gigabyte * 1024;
      if (bytes >= 0 && bytes < kilobyte) {
        return bytes + ' B';
      } else if (bytes >= kilobyte && bytes < megabyte) {
        return (bytes / kilobyte).toFixed(precision) + ' KB';
      } else if (bytes >= megabyte && bytes < gigabyte) {
        return (bytes / megabyte).toFixed(precision) + ' MB';
      } else if (bytes >= gigabyte && bytes < terabyte) {
        return (bytes / gigabyte).toFixed(precision) + ' GB';
      } else if (bytes >= terabyte) {
        return (bytes / terabyte).toFixed(precision) + ' TB';
      } else {
        return bytes + ' B';
      }
    };
    getTestUrl = function(format) {
      var params, testUrl;
      testUrl = "" + $scope.wsName + "/data/" + $scope.dfName;
      if ($scope.key.length) {
        testUrl += "/" + $scope.key;
      }
      params = [];
      if ($scope.customParams.length) {
        params.push($scope.customParams);
      }
      params.push('format=' + format);
      if (params.length) {
        testUrl += "?" + params.join('&');
      }
      $scope.url = testUrl;
      return testUrl;
    };
  });

}).call(this);
