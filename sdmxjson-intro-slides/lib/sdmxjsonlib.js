// Generated by CoffeeScript 1.6.3
(function() {
  var KEY_SEPARATOR, lib, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  KEY_SEPARATOR = ':';

  lib = {
    request: {},
    response: {}
  };

  lib.version = '0.1.1';

  lib._normalizeSdmxIdString = function(id) {
    var normalizeIdPart;
    normalizeIdPart = function(s, i) {
      if (i === 0) {
        return s;
      } else {
        return s.substr(0, 1).toUpperCase() + s.substr(1);
      }
    };
    return id.toLowerCase().split('_').map(normalizeIdPart).join('');
  };

  lib.response.mapStructure = function(obj, iterator, ignoreDatasetLevel, context) {
    var key, results, value, _iterator, _ref, _ref1;
    if (iterator == null) {
      iterator = lib.response.mapComponent;
    }
    if (ignoreDatasetLevel == null) {
      ignoreDatasetLevel = true;
    }
    results = [];
    if (obj == null) {
      return results;
    }
    _iterator = function(d, type, level) {
      return results.push(iterator.call(context, d, type, level));
    };
    _ref = obj.structure.dimensions;
    for (key in _ref) {
      value = _ref[key];
      if (key === 'dataSet' && ignoreDatasetLevel) {
        continue;
      }
      value.forEach(function(d) {
        return _iterator(d, 'dimension', key);
      });
    }
    _ref1 = obj.structure.attributes;
    for (key in _ref1) {
      value = _ref1[key];
      if (key === 'dataSet' && ignoreDatasetLevel) {
        continue;
      }
      value.forEach(function(d) {
        return _iterator(d, 'attribute', key);
      });
    }
    return results;
  };

  lib.response.mapComponent = function(obj, type, level) {
    return obj;
  };

  lib.response.mapDataSets = function(obj, iterator, ignoreDatasetLevel, context) {
    var a, allAttributes, allDimensions, attributes, d, dimensions, ds, dsAttrIdx, dsAttrVals, dsDimIdx, dsDimVals, i, key, key1, key2, obsAttrIdx, obsDimIdx, resultObs, results, serAttrIdx, serAttrVals, serDimIdx, serDimVals, value, value1, value2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (iterator == null) {
      iterator = lib.response.mapObservationToObject;
    }
    if (ignoreDatasetLevel == null) {
      ignoreDatasetLevel = true;
    }
    results = [];
    if (obj == null) {
      return results;
    }
    dimensions = obj.structure.dimensions;
    attributes = obj.structure.attributes;
    dsDimIdx = dsDimVals = [];
    dsAttrIdx = dsAttrVals = [];
    allDimensions = [].concat((_ref = dimensions.series) != null ? _ref : [], (_ref1 = dimensions.observation) != null ? _ref1 : []);
    allAttributes = [].concat((_ref2 = attributes.series) != null ? _ref2 : [], (_ref3 = attributes.observation) != null ? _ref3 : []);
    if (!ignoreDatasetLevel) {
      if (dimensions.dataSet != null) {
        _ref4 = dimensions.dataSet;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          d = _ref4[_i];
          dsDimVals.push(d.values[0]);
          dsDimIdx = dsDimVals.map(function(d) {
            return 0;
          });
        }
      }
      if (attributes.dataSet != null) {
        _ref5 = attributes.dataSet;
        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
          a = _ref5[_j];
          dsAttrVals.push(a.values[0]);
          dsAttrIdx = dsAttrVals.map(function(d) {
            return 0;
          });
        }
      }
      allDimensions = [].concat((_ref6 = dimensions.dataSet) != null ? _ref6 : [], allDimensions);
      allAttributes = [].concat((_ref7 = attributes.dataSet) != null ? _ref7 : [], allAttributes);
    }
    _ref8 = obj.dataSets;
    for (_k = 0, _len2 = _ref8.length; _k < _len2; _k++) {
      ds = _ref8[_k];
      if (ds.observations != null) {
        _ref9 = ds.observations;
        for (key in _ref9) {
          value = _ref9[key];
          obsDimIdx = key.split(KEY_SEPARATOR).map(function(v) {
            return +v;
          });
          obsAttrIdx = value.slice(1);
          resultObs = {
            seriesKey: null,
            dimensionIndices: dsDimIdx.concat(obsDimIdx),
            dimensions: dsDimVals.concat((function() {
              var _l, _len3, _results;
              _results = [];
              for (i = _l = 0, _len3 = obsDimIdx.length; _l < _len3; i = ++_l) {
                d = obsDimIdx[i];
                _results.push(dimensions.observation[i].values[d]);
              }
              return _results;
            })()),
            attributeIndices: dsAttrIdx.concat(obsAttrIdx),
            attributes: dsDimVals.concat((function() {
              var _l, _len3, _results;
              _results = [];
              for (i = _l = 0, _len3 = obsAttrIdx.length; _l < _len3; i = ++_l) {
                d = obsAttrIdx[i];
                _results.push(attributes.observation[i].values[d]);
              }
              return _results;
            })()),
            value: value[0]
          };
          results.push(iterator.call(context, resultObs, allDimensions, allAttributes));
        }
      }
      if (ds.series != null) {
        _ref10 = ds.series;
        for (key1 in _ref10) {
          value1 = _ref10[key1];
          serDimIdx = key1.split(KEY_SEPARATOR).map(function(v) {
            return +v;
          });
          serAttrIdx = (_ref11 = value1.attributes) != null ? _ref11 : [];
          serDimVals = dsDimVals.concat((function() {
            var _l, _len3, _results;
            _results = [];
            for (i = _l = 0, _len3 = serDimIdx.length; _l < _len3; i = ++_l) {
              d = serDimIdx[i];
              _results.push(dimensions.series[i].values[d]);
            }
            return _results;
          })());
          serAttrVals = dsAttrVals.concat((function() {
            var _l, _len3, _results;
            _results = [];
            for (i = _l = 0, _len3 = serAttrIdx.length; _l < _len3; i = ++_l) {
              d = serAttrIdx[i];
              _results.push(attributes.series[i].values[d]);
            }
            return _results;
          })());
          serDimIdx = dsDimIdx.concat(serDimIdx);
          serAttrIdx = dsAttrIdx.concat(serAttrIdx);
          _ref12 = value1.observations;
          for (key2 in _ref12) {
            value2 = _ref12[key2];
            obsDimIdx = key2.split(KEY_SEPARATOR).map(function(v) {
              return +v;
            });
            obsAttrIdx = value2.slice(1);
            resultObs = {
              seriesKey: serDimIdx.join(KEY_SEPARATOR),
              dimensionIndices: serDimIdx.concat(obsDimIdx),
              dimensions: serDimVals.concat((function() {
                var _l, _len3, _results;
                _results = [];
                for (i = _l = 0, _len3 = obsDimIdx.length; _l < _len3; i = ++_l) {
                  d = obsDimIdx[i];
                  _results.push(dimensions.observation[i].values[d]);
                }
                return _results;
              })()),
              attributeIndices: serAttrIdx.concat(obsAttrIdx),
              attributes: serAttrVals.concat((function() {
                var _l, _len3, _results;
                _results = [];
                for (i = _l = 0, _len3 = obsAttrIdx.length; _l < _len3; i = ++_l) {
                  d = obsAttrIdx[i];
                  _results.push(attributes.observation[i].values[d]);
                }
                return _results;
              })()),
              value: value2[0]
            };
            results.push(iterator.call(context, resultObs, allDimensions, allAttributes));
          }
        }
      }
    }
    return results;
  };

  lib.response.mapObservationToObject = function(observation) {
    return observation;
  };

  lib.response.mapObservationToObjectWithKeys = function(observation, dimensions, attributes) {
    var a, d, i, result, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    result = {
      seriesKey: observation.seriesKey,
      obsValue: observation.value
    };
    _ref = observation.dimensions;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      d = _ref[i];
      result[(_ref1 = dimensions[i].propertyName) != null ? _ref1 : dimensions[i].id] = d;
    }
    _ref2 = observation.attributes;
    for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
      a = _ref2[i];
      result[(_ref3 = attributes[i].propertyName) != null ? _ref3 : attributes[i].id] = a;
    }
    return result;
  };

  lib.response.addStartAndEndDatesToTimeDimension = function(msg) {
    var key, mapDimension, mapStartAndEnd, value, _ref;
    if (msg == null) {
      return msg;
    }
    mapStartAndEnd = function(value) {
      if (value.start != null) {
        value.startDate = new Date(value.start);
      }
      if (value.end != null) {
        return value.endDate = new Date(value.end);
      }
    };
    mapDimension = function(dim) {
      return dim.values.forEach(mapStartAndEnd);
    };
    _ref = msg.structure.dimensions;
    for (key in _ref) {
      value = _ref[key];
      value.forEach(mapDimension);
    }
    return msg;
  };

  lib.response.addPropertyNamesToComponents = function(msg) {
    var key, value, _ref, _ref1;
    if (!msg) {
      return msg;
    }
    _ref = msg.structure.dimensions;
    for (key in _ref) {
      value = _ref[key];
      value.forEach(function(d) {
        return d.propertyName = lib._normalizeSdmxIdString(d.id);
      });
    }
    _ref1 = msg.structure.attributes;
    for (key in _ref1) {
      value = _ref1[key];
      value.forEach(function(a) {
        return a.propertyName = lib._normalizeSdmxIdString(a.id);
      });
    }
    return msg;
  };

  root.sdmxjsonlib = lib;

  /*
  
  #-------------------------------------------------------------------------------
  
  lib.mapSeries = (obj, iterator = lib.mapSeriesToObject, ingnoreDatasetLevel = true, context) ->
      results = []
      return results unless obj?
  
      dims = obj.structure.dimensions
      attrs = obj.structure.attributes
  
      dimensions =
          observation: dims.observation
  
      attributes =
          observation: attrs.observation
  
      if ingnoreDatasetLevel
          dimensions.series = dims.series
          attributes.series = attrs.series
          dsDimVals = []
          dsAttrVals = []
      else
          dimensions.series = [].concat (dims.dataSet ? []), (dims.series ? [])
          attributes.series = [].concat (attrs.dataSet ? []), (attrs.series ? [])
          dsDimVals = (0 for x in [0...(dims.dataSet?.length ? 0)])
          dsAttrVals = (0 for x in [0...(attrs.dataSet?.length ? 0)])
  
      for ds in obj.dataSets
          continue unless ds.series?
  
          for key1, value1 of ds.series
              series =
                  dimensionIndices: dsDimVals.concat key1.split(KEY_SEPARATOR).map (v) -> +v
                  dimensions: []
                  attributeIndices: dsAttrVals.concat (value1.attributes ? [])
                  attributes: []
                  observations: []
  
              series.dimensions = (dimensions.series[j].values[i] for i, j in series.dimensionIndices)
              series.attributes = (attributes.series[j].values[i] for i, j in series.attributeIndices)
  
              for key2, value2 of value1.observations
                  observation =
                      dimensionIndices: key2.split(KEY_SEPARATOR).map (v) -> +v
                      dimensions: []
                      attributeIndices: value2[1..]
                      attributes: []
                      value: value2[0]
  
                  observation.dimensions = (dimensions.observation[j].values[i] for i, j in observation.dimensionIndices)
                  observation.attributes = (attributes.observation[j].values[i] for i, j in observation.attributeIndices)
  
                  series.observations.push observation
  
              results.push iterator.call(context, series, dimensions, attributes)
  
      results
  
  
  lib.mapSeriesToObject = (series) -> series
  
  
  lib.mapSeriesToObjectWithKeys = (series, dimensions, attributes) ->
      result =
          dimensions: {}
          attributes: {}
          observations: []
  
      result.dimensions[ lib.normalizeSdmxIdString(dimensions.series[j].id) ] = i for i, j in series.dimensions
      result.attributes[ lib.normalizeSdmxIdString(attributes.series[j].id) ] = i for i, j in series.attributes
  
      mapObservation = (obs) -> lib.mapObservationToObjectWithKeys obs, dimensions.observation, attributes.observation
  
      result.observations = series.observations.map mapObservation
  
      result
  
  
  lib.map1 = (obj, iterator, context, ingnoreDatasetLevel = true ) ->
      results = []
      return results unless obj?
  
      dims = obj.structure.dimensions
      allDims = [].concat (dims.dataSet ? []), (dims.series ? []), (dims.observation ? [])
      dsDimVals = (0 for x in [0...(dims.dataSet?.length ? 0)])
  
      attrs = obj.structure.attributes
      allAttrs = [].concat (attrs.dataSet ? []), (attrs.series ? []), (attrs.observation ? [])
      dsAttrVals = (0 for x in [0...(attrs.dataSet?.length ? 0)])
  
      for ds in obj.dataSets
          if ds.observations?
              for key, value of ds.observations
                  dimVals = dsDimVals.concat key.split(KEY_SEPARATOR).map (v) -> +v
                  obsVal = value[0]
                  attrVals = dsAttrVals.concat value[1..]
                  results.push iterator.call(context, dimVals, obsVal, attrVals, allDims, allAttrs)
          else if ds.series?
              for key1, value1 of ds.series
                  serDimVals = dsDimVals.concat key1.split(KEY_SEPARATOR).map (v) -> +v
                  serAttrVals = dsAttrVals.concat (value1.attributes ? [])
                  for key2, value2 of value1.observations
                      dimVals = serDimVals.concat key2.split(KEY_SEPARATOR).map (v) -> +v
                      obsVal = value2[0]
                      attrVals = serAttrVals.concat value2[1..]
                      results.push iterator.call(context, dimVals, obsVal, attrVals, allDims, allAttrs)
  
      results
  
  
  lib.mapObservationToIndexArray = (dimVals, obsVal, attrVals) ->
      result = dimVals.concat []
      result.push obsVal
      result = result.concat attrVals
      result
  
  
  lib.mapObservationToArray = (dimVals, obsVal, attrVals, allDims, allAttrs) ->
      result = []
      result.push allDims[i].values[d] for d, i in dimVals
      result.push obsVal
      result.push allAttrs[i].values[a] for a, i in attrVals
      result
  
  
  lib.mapObservationToObject1 = (dimVals, obsVal, attrVals, allDims, allAttrs) ->
      result = {}
      result[ allDims[i].id.toLowerCase() ] = allDims[i].values[d] for d, i in dimVals
      result.obs_value = obsVal
      result[ allAttrs[i].id.toLowerCase() ] = allAttrs[i].values[a] for a, i in attrVals
      result
  
  
  lib.mapObservationToObjectWithKeys3 = (observation, dimensions, attributes) ->
      result =
          dimensions: {}
          attributes: {}
          obs_value: observation.value
  
      result.dimensions[ dimensions[i].id.toLowerCase() ] = d for d, i in observation.dimensions
      result.attributes[ attributes[i].id.toLowerCase() ] = a for a, i in observation.attributes
  
      result
  
  
  lib.mapSeries1 = (obj, iterator, context, ingnoreDatasetLevel = true) ->
      results = []
  
      dims = obj.structure.dimensions
      attrs = obj.structure.attributes
  
      dimensions =
          observation: dims.observation
  
      attributes =
          observation: attrs.observation
  
      if ingnoreDatasetLevel
          dimensions.series = dims.series
          attributes.series = attrs.series
          dsDimVals = []
          dsAttrVals = []
      else
          dimensions.series = [].concat (dims.dataSet ? []), (dims.series ? [])
          attributes.series = [].concat (attrs.dataSet ? []), (attrs.series ? [])
          dsDimVals = (0 for x in [0...(dims.dataSet?.length ? 0)])
          dsAttrVals = (0 for x in [0...(attrs.dataSet?.length ? 0)])
  
      for ds in obj.dataSets
          for key1, value1 of ds.series
              serDimVals = dsDimVals.concat key1.split(KEY_SEPARATOR).map (v) -> +v
              serAttrVals = dsAttrVals.concat (value1.attributes ? [])
              obsDimVals = []
              obsVals = []
              obsAttrVals = []
              for key2, value2 of value1.observations
                  obsDimVals.push key2.split(KEY_SEPARATOR).map (v) -> +v
                  obsVals.push value2[0]
                  obsAttrVals.push value2[1..]
              results.push iterator.call(context, serDimVals, serAttrVals, obsDimVals, obsVals, obsAttrVals, dims, attrs)
  
      results
  
  
  lib.mapSeriesToArray1 = (serDimVals, serAttrVals, obsDimVals, obsVals, obsAttrVals, dims, attrs) ->
      result = []
      result.push dims.series[i].values[d] for d, i in serDimVals
      allResultObs = []
      for obsVal, i in obsVals
          resultObs = []
          resultObs.push dims.observation[j].values[d] for d, j in obsDimVals[i]
          resultObs.push obsVal
          resultObs.push attrs.observation[j].values[a] for a, j in obsAttrVals[i]
          allResultObs.push resultObs
      result.push allResultObs
      result.push attrs.series[i].values[a] for a, i in serAttrVals
      result
  
  
  lib.mapSeriesToObject1 = (serDimVals, serAttrVals, obsDimVals, obsVals, obsAttrVals, dims, attrs) ->
      result = {}
      result[ dims.series[i].id.toLowerCase() ] = dims.series[i].values[d] for d, i in serDimVals
      allResultObs = []
      for obsVal, i in obsVals
          resultObs = {}
          resultObs[ dims.observation[j].id.toLowerCase() ] = dims.observation[j].values[d] for d, j in obsDimVals[i]
          resultObs.obs_value = obsVal
          resultObs[ attrs.observation[j].id.toLowerCase() ] = attrs.observation[j].values[a] for a, j in obsAttrVals[i]
          allResultObs.push resultObs
      result.observations = allResultObs
      result[ attrs.series[i].id.toLowerCase() ] = attrs.series[i].values[a] for a, i in serAttrVals
      result
  */


}).call(this);
