// Generated by CoffeeScript 1.6.2
(function() {
  var DATA_FILE, FULL_RESPONSE_FILE, HTTP_BAD_REQUEST, HTTP_INTERNAL_SERVER_ERROR, HTTP_METHOD_NOT_ALLOWED, HTTP_NOT_ACCEPTABLE, HTTP_NOT_FOUND, HTTP_NOT_IMPLEMENTED, HTTP_OK, HTTP_UNAUTHORIZED, KEY_SEPARATOR, NODE_ENV, PORT_NUMBER, SERVER_NAME, SERVER_VERSION, calculateIndexMultipliers, compressResponse, dataset, findDataFlow, fs, getDimensionAtObservation, getDocs, handleRequest, http, loadDataset, log, mapCodesInQuery, parse, parseDataQuery, parseDate, parseFlowRef, parseKey, parseProviderRef, parseQueryParams, path, preProcessMessage, query, server, test, timePeriodToDate, url, util, validateRequest, zlib;

  http = require('http');

  url = require('url');

  fs = require('fs');

  path = require('path');

  zlib = require('zlib');

  util = require('util');

  SERVER_NAME = 'LIVE-TEST-WS-7';

  SERVER_VERSION = '0.6.10';

  PORT_NUMBER = process.env.PORT || 8081;

  NODE_ENV = process.env.NODE_ENV || 'test';

  DATA_FILE = 'hicp-coicop-inx-sdmx.json';

  FULL_RESPONSE_FILE = 'full-response.json';

  HTTP_OK = 200;

  HTTP_BAD_REQUEST = 400;

  HTTP_UNAUTHORIZED = 401;

  HTTP_NOT_FOUND = 404;

  HTTP_METHOD_NOT_ALLOWED = 405;

  HTTP_NOT_ACCEPTABLE = 406;

  HTTP_INTERNAL_SERVER_ERROR = 500;

  HTTP_NOT_IMPLEMENTED = 501;

  KEY_SEPARATOR = ':';

  dataset = null;

  log = function(msg) {
    return console.log("" + (new Date().toTimeString().slice(0, 8)) + " " + msg);
  };

  calculateIndexMultipliers = function(dimensions) {
    var dim, i, multipliers, prev, reversedDimensions, _i, _len;

    multipliers = new Array(dimensions.length);
    reversedDimensions = dimensions.slice().reverse();
    prev = 1;
    for (i = _i = 0, _len = reversedDimensions.length; _i < _len; i = ++_i) {
      dim = reversedDimensions[i];
      multipliers[i] = prev;
      prev = dim.length * prev;
    }
    return multipliers.reverse();
  };

  loadDataset = function(filename) {
    var jsonString, msg;

    jsonString = fs.readFileSync(filename);
    msg = JSON.parse(jsonString);
    return preProcessMessage(msg);
  };

  preProcessMessage = function(msg) {
    var attr, dim, ext, flattenFlatDataSet, flattenGrouppedDataSet, key, str, value, _base, _base1, _base2, _base3, _base4, _base5, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;

    str = msg.structure;
    flattenGrouppedDataSet = function(ds) {
      var i, key, newObs, obsAttrCount, obsDimCount, obsDims, obsKey, series, seriesAttrCount, seriesDimCount, seriesDims, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3;

      if (ds.observations != null) {
        return;
      }
      if (ds.series == null) {
        return;
      }
      obsDimCount = str.dimensions.observation.length;
      seriesDimCount = str.dimensions.series.length;
      obsAttrCount = str.attributes.observation.length;
      seriesAttrCount = str.attributes.series.length;
      str.dimensions = {
        dataSet: str.dimensions.dataSet,
        series: [],
        observation: str.dimensions.series.concat(str.dimensions.observation)
      };
      str.attributes = {
        dataSet: str.attributes.dataSet,
        series: [],
        observation: str.attributes.observation.concat(str.attributes.series)
      };
      ds.observations = [];
      _ref = Object.keys(ds.series);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        seriesDims = key.split(KEY_SEPARATOR).map(function(d) {
          return +d;
        });
        series = ds.series[key];
        _ref1 = Object.keys(series.observations);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          obsKey = _ref1[_j];
          obsDims = obsKey.split(KEY_SEPARATOR).map(function(d) {
            return +d;
          });
          newObs = new Array(seriesDimCount + obsDimCount + 1 + obsAttrCount + seriesAttrCount);
          for (i = _k = 0, _len2 = seriesDims.length; _k < _len2; i = ++_k) {
            val = seriesDims[i];
            newObs[i] = val;
          }
          for (i = _l = 0, _len3 = obsDims.length; _l < _len3; i = ++_l) {
            val = obsDims[i];
            newObs[i + seriesDimCount] = val;
          }
          _ref2 = series.observations[obsKey];
          for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
            val = _ref2[i];
            newObs[i + seriesDimCount + obsDimCount] = val;
          }
          _ref3 = series.attributes;
          for (i = _n = 0, _len5 = _ref3.length; _n < _len5; i = ++_n) {
            val = _ref3[i];
            newObs[i + seriesDimCount + obsDimCount + 1 + obsAttrCount] = val;
          }
          ds.observations.push(newObs);
        }
      }
      return delete ds.series;
    };
    flattenFlatDataSet = function(ds) {
      var dims, i, key, newObs, observations, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

      if (ds.observations == null) {
        return;
      }
      observations = [];
      _ref = Object.keys(ds.observations);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        dims = key.split(KEY_SEPARATOR);
        newObs = new Array(dims.length + 1 + str.attributes.observation.length);
        for (i = _j = 0, _len1 = dims.length; _j < _len1; i = ++_j) {
          val = dims[i];
          newObs[i] = val;
        }
        _ref1 = ds.observations[key];
        for (i = _k = 0, _len2 = _ref1.length; _k < _len2; i = ++_k) {
          val = _ref1[i];
          newObs[i + dims.length] = val;
        }
        observations.push(newObs);
      }
      return ds.observations = observations;
    };
    msg.dataSets.forEach(flattenFlatDataSet);
    msg.dataSets.forEach(flattenGrouppedDataSet);
    ext = str.extensions = {
      componentMap: {},
      keyDimensions: [],
      dimensions: [],
      attributeMap: {}
    };
    if ((_ref = str.dimension) == null) {
      str.dimension = {};
    }
    if ((_ref1 = (_base = str.dimensions).dataSet) == null) {
      _base.dataSet = [];
    }
    if ((_ref2 = (_base1 = str.dimensions).series) == null) {
      _base1.series = [];
    }
    if ((_ref3 = (_base2 = str.dimensions).observation) == null) {
      _base2.observation = [];
    }
    if ((_ref4 = str.attributes) == null) {
      str.attributes = {};
    }
    if ((_ref5 = (_base3 = str.attributes).dataSet) == null) {
      _base3.dataSet = [];
    }
    if ((_ref6 = (_base4 = str.attributes).series) == null) {
      _base4.series = [];
    }
    if ((_ref7 = (_base5 = str.attributes).observation) == null) {
      _base5.observation = [];
    }
    _ref8 = str.dimensions;
    for (key in _ref8) {
      value = _ref8[key];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        dim = value[_i];
        ext.dimensions.push(dim);
        ext.componentMap[dim.id] = dim;
        if (dim.id === 'TIME_PERIOD') {
          ext.timeDimension = dim;
        } else {
          ext.keyDimensions.push(dim);
        }
      }
    }
    _ref9 = str.attributes;
    for (key in _ref9) {
      value = _ref9[key];
      for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
        attr = value[_j];
        ext.attributeMap[attr.id] = attr;
        ext.componentMap[attr.id] = attr;
      }
    }
    ext.keyDimensions.sort(function(a, b) {
      return a.keyPosition > b.keyPosition;
    });
    return msg;
  };

  exports.timePeriodToDate = timePeriodToDate = function(frequency, year, period, end) {
    var date;

    if (year % 1 !== 0) {
      return null;
    }
    if (period % 1 !== 0) {
      return null;
    }
    if (period < 1) {
      return null;
    }
    date = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
    if (!end) {
      period = period - 1;
    }
    switch (frequency) {
      case 'A':
        if (1 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (12 * period));
        break;
      case 'S':
        if (2 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (6 * period));
        break;
      case 'T':
        if (3 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (4 * period));
        break;
      case 'Q':
        if (4 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (3 * period));
        break;
      case 'M':
        if (12 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + period);
        break;
      case 'W':
        if (53 < period) {
          return null;
        }
        if (date.getUTCDay() !== 4) {
          date.setUTCMonth(0, 1 + (((4 - date.getUTCDay()) + 7) % 7));
        }
        date.setUTCDate(date.getUTCDate() - 3);
        date.setUTCDate(date.getUTCDate() + (7 * period));
        break;
      case 'D':
        if (366 < period) {
          return null;
        }
        date.setUTCDate(date.getUTCDate() + period);
        break;
      default:
        return null;
    }
    return date;
  };

  exports.parseDate = parseDate = function(value, end) {
    var date, millisecs;

    date = null;
    if (/^\d\d\d\d-[A|S|T|Q]\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value[6], end);
    } else if (/^\d\d\d\d-[M|W]\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 8), end);
    } else if (/^\d\d\d\d-D\d\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 9), end);
    } else {
      millisecs = Date.parse(value);
      if (isNaN(millisecs)) {
        return null;
      }
      date = new Date(millisecs);
      if (end) {
        switch (value.length) {
          case 4:
            date.setUTCFullYear(date.getUTCFullYear() + 1);
            break;
          case 7:
            date.setUTCMonth(date.getUTCMonth() + 1);
            break;
          case 10:
            date.setUTCDate(date.getUTCDate() + 1);
        }
      }
    }
    if ((date != null) && end) {
      date.setUTCSeconds(date.getUTCSeconds() - 1);
    }
    return date;
  };

  exports.parseFlowRef = parseFlowRef = function(flowRefStr, request, response) {
    var flowRef, regex;

    if (flowRefStr == null) {
      response.result.errors.push('Mandatory parameter flowRef is missing');
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    regex = /^(([A-z0-9_@$\-]+)|(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*)(\,[A-z0-9_@$\-]+)(\,(latest|([0-9]+(\.[0-9]+)*)))?))$/;
    if (!regex.test(flowRefStr)) {
      response.result.errors.push("Invalid parameter flowRef " + flowRefStr);
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    flowRef = flowRefStr.split(',');
    if (flowRef.length === 1) {
      flowRef[1] = flowRef[0];
      flowRef[0] = 'all';
    }
    if ((flowRef[2] == null) || flowRef[2] === '') {
      flowRef[2] = 'latest';
    }
    return request.query.flowRef = {
      agencyID: flowRef[0],
      id: flowRef[1],
      version: flowRef[2]
    };
  };

  exports.parseKey = parseKey = function(keyStr, request, response) {
    var code, codes, dim, dims, i, key, regex, _i, _j, _len, _len1;

    if (keyStr == null) {
      keyStr = 'all';
    }
    if (keyStr === 'all') {
      request.query.key = 'all';
      return;
    }
    regex = /^(([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?([.]([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?)*)$/;
    if (!regex.test(keyStr)) {
      response.result.errors.push("Invalid parameter flowRef " + keyStr);
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    key = [];
    dims = keyStr.split('.');
    for (i = _i = 0, _len = dims.length; _i < _len; i = ++_i) {
      dim = dims[i];
      codes = dim.split('+');
      key[i] = [];
      for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
        code = codes[_j];
        if (code !== '') {
          key[i].push(code);
        }
      }
      if (-1 < dim.indexOf('+') && key[i].length === 0) {
        response.result.errors.push("Invalid parameter key " + keyStr);
        response.statusCode = HTTP_BAD_REQUEST;
        return;
      }
    }
    return request.query.key = key;
  };

  exports.parseProviderRef = parseProviderRef = function(providerRefStr, request, response) {
    var providerRef, regex;

    if (providerRefStr == null) {
      providerRefStr = 'all';
    }
    regex = /^(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*\,)?([A-z0-9_@$\-]+))$/;
    if (!regex.test(providerRefStr)) {
      response.result.errors.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    providerRef = providerRefStr.split(',');
    switch (providerRef.length) {
      case 1:
        if (providerRef[0] !== 'all') {
          providerRef[1] = providerRef[0];
          providerRef[0] = 'all';
        }
    }
    if ((providerRef[0] == null) || providerRef[0] === '') {
      providerRef[0] = 'all';
    }
    if ((providerRef[1] == null) || providerRef[1] === '') {
      providerRef[1] = 'all';
    }
    if (providerRef.length !== 2) {
      response.result.errors.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    return request.query.providerRef = {
      agencyID: providerRef[0],
      id: providerRef[1]
    };
  };

  exports.parseQueryParams = parseQueryParams = function(request, response) {
    var date, param, parameters, value;

    parameters = url.parse(request.url, true, false).query;
    for (param in parameters) {
      value = parameters[param];
      switch (param) {
        case 'startPeriod':
        case 'endPeriod':
          date = parseDate(value, param === 'endPeriod');
          if (date != null) {
            request.query[param] = date;
            continue;
          }
          break;
        case 'firstNObservations':
        case 'lastNObservations':
          if (0 < +value) {
            request.query[param] = +value;
            continue;
          }
          break;
        case 'updatedAfter':
          response.statusCode = HTTP_NOT_IMPLEMENTED;
          return;
        case 'dimensionAtObservation':
          request.query[param] = value;
          continue;
        case 'detail':
          switch (value) {
            case 'full':
            case 'dataonly':
            case 'nodata':
            case 'serieskeysonly':
              request.query[param] = value;
              continue;
          }
          break;
        case 'extraParams':
          request.query.extraParams = value;
          continue;
      }
      response.result.errors.push("Invalid query parameter " + param + " value " + value);
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
  };

  parseDataQuery = function(path, request, response) {
    parseFlowRef(path[2], request, response);
    if (response.statusCode !== HTTP_OK) {
      return;
    }
    parseKey(path[3], request, response);
    if (response.statusCode !== HTTP_OK) {
      return;
    }
    parseProviderRef(path[4], request, response);
    if (response.statusCode !== HTTP_OK) {
      return;
    }
    parseQueryParams(request, response);
    if (response.statusCode !== HTTP_OK) {

    }
  };

  parse = function(request, response) {
    request.query = {};
    request.query.resource = request.path[1];
    switch (request.query.resource) {
      case 'data':
        return parseDataQuery(request.path, request, response);
      default:
        response.statusCode = HTTP_NOT_IMPLEMENTED;
    }
  };

  findDataFlow = function(request, response) {
    var found;

    found = true;
    found &= (function() {
      switch (request.query.flowRef.agencyID) {
        case 'all':
        case 'ECB':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.id) {
        case 'ECB_ICP1':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.version) {
        case 'latest':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.agencyID) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.id) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    if (!found) {
      response.statusCode = HTTP_NOT_FOUND;
      response.result.errors.push("Data flow not found");
      return;
    }
    return dataset;
  };

  mapCodesInQuery = function(request, response, msg) {
    var code, codeMap, codePositions, dim, endDate, i, j, key, keyCodes, period, periods, query, startDate, timeDimension, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;

    key = msg.structure.extensions.keyDimensions;
    query = {};
    periods = {};
    timeDimension = msg.structure.extensions.timeDimension;
    _ref = timeDimension.values;
    for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
      period = _ref[j];
      if (request.query.startPeriod != null) {
        startDate = parseDate(period.id, false);
        if (!(request.query.startPeriod <= startDate)) {
          continue;
        }
      }
      if (request.query.endPeriod != null) {
        endDate = parseDate(period.id, true);
        if (!(endDate <= request.query.endPeriod)) {
          continue;
        }
      }
      periods[j] = 1;
    }
    query[timeDimension.id] = periods;
    if (request.query.key === 'all') {
      codePositions = {};
      for (_j = 0, _len1 = key.length; _j < _len1; _j++) {
        dim = key[_j];
        _ref1 = dim.values;
        for (j = _k = 0, _len2 = _ref1.length; _k < _len2; j = ++_k) {
          code = _ref1[j];
          codePositions[j] = 1;
        }
        query[dim.id] = codePositions;
      }
      return query;
    }
    if (request.query.key.length !== key.length) {
      response.result.errors.push("Invalid number of dimensions in parameter key");
      response.statusCode = HTTP_BAD_REQUEST;
      return;
    }
    _ref2 = request.query.key;
    for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
      keyCodes = _ref2[i];
      dim = key[i];
      codePositions = {};
      if (keyCodes.length === 0) {
        _ref3 = dim.values;
        for (j = _m = 0, _len4 = _ref3.length; _m < _len4; j = ++_m) {
          code = _ref3[j];
          codePositions[j] = 1;
        }
        query[dim.id] = codePositions;
        continue;
      }
      codeMap = {};
      _ref4 = dim.values;
      for (j = _n = 0, _len5 = _ref4.length; _n < _len5; j = ++_n) {
        code = _ref4[j];
        codeMap[code.id] = j;
      }
      for (_o = 0, _len6 = keyCodes.length; _o < _len6; _o++) {
        code = keyCodes[_o];
        codePositions[codeMap[code] != null ? codeMap[code] : -1] = 1;
      }
      query[dim.id] = codePositions;
    }
    return query;
  };

  getDimensionAtObservation = function(msg, request, response) {
    var dimAtObs;

    dimAtObs = request.query.dimensionAtObservation;
    if (dimAtObs == null) {
      return 'TIME_PERIOD';
    }
    if (dimAtObs === 'AllDimensions') {
      return dimAtObs;
    }
    if (!msg.structure.extensions.dimensions.some(function(dim) {
      return dim.id === dimAtObs;
    })) {
      response.statusCode = HTTP_BAD_REQUEST;
      response.result.errors.push("Invalid value for parameter dimensionAtObservation " + dimAtObs);
    }
    return dimAtObs;
  };

  query = function(msg, request, response) {
    var addIndices, attrGroupings, codesInQuery, comp, componentValuesInResults, components, count, counter, dimAtObs, dimGroupings, dropDimension, emptyAttributes, filterDataSet, filterEmptyAttributes, filterGrouppedAttributes, filterGrouppedDimensions, filterObservation, findAttributeToGroup, findDimensionToGroup, formatDataSet, fullDataSet, groupAttributes, groupDimensions, key, key2, mapComponent, mapDataSetToResult, mapObservation, minObsCount, obsDimCount, pos, rebaseArray, rebaseDataSet, rebaseObservation, rslt, str, unGroupDataSetDimensions, value, value2, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;

    rslt = response.result;
    str = msg.structure;
    dimAtObs = getDimensionAtObservation(msg, request);
    if (response.statusCode !== HTTP_OK) {
      return;
    }
    fullDataSet = true;
    fullDataSet = fullDataSet && (request.query.startPeriod == null);
    fullDataSet = fullDataSet && (request.query.endPeriod == null);
    fullDataSet = fullDataSet && request.query.key === 'all';
    fullDataSet = fullDataSet && (request.query.detail == null);
    fullDataSet = fullDataSet && (dimAtObs == null);
    if (fullDataSet) {
      rslt.dataSets = msg.dataSets;
      rslt.structure = msg.structure;
      return;
    }
    codesInQuery = mapCodesInQuery(request, response, msg);
    if (response.statusCode !== HTTP_OK) {
      return;
    }
    componentValuesInResults = {};
    _ref = msg.structure.dimensions;
    for (key in _ref) {
      value = _ref[key];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        comp = value[_i];
        componentValuesInResults[comp.id] = {};
      }
    }
    _ref1 = msg.structure.attributes;
    for (key in _ref1) {
      value = _ref1[key];
      for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
        comp = value[_j];
        componentValuesInResults[comp.id] = {};
      }
    }
    filterDataSet = function(dataSet) {
      var dimId, i, _k, _l, _len2, _len3, _ref2, _ref3;

      if (dataSet.dataSetAction === 'Delete') {
        return false;
      }
      if (str.dimensions.dataSet.length === 0) {
        return true;
      }
      _ref2 = dataSet.dimensions;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        value = _ref2[i];
        dimId = str.dimensions.dataSet[i].id;
        if (codesInQuery[dimId][value] == null) {
          return false;
        }
        componentValuesInResults[dimId][value] = 1;
      }
      _ref3 = dataSet.attributes;
      for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
        value = _ref3[i];
        if (!(value != null)) {
          continue;
        }
        dimId = str.attributes.dataSet[i].id;
        componentValuesInResults[dimId][value] = 1;
      }
      return true;
    };
    mapDataSetToResult = function(ds) {
      var result, _ref2, _ref3;

      result = {
        id: ds.id,
        action: ds.action,
        extracted: ds.extracted,
        name: ds.name,
        description: ds.description,
        dimensions: [],
        attributes: [],
        annotations: []
      };
      if (ds.dimensions != null) {
        result.dimensions = ds.dimensions.slice();
      }
      if (ds.attributes != null) {
        result.attributes = (_ref2 = ds.attributes) != null ? _ref2.slice() : void 0;
      }
      result.observations = (_ref3 = ds.observations) != null ? _ref3.filter(filterObservation).map(mapObservation) : void 0;
      return result;
    };
    filterObservation = function(obs) {
      var dim, i, _k, _len2, _ref2;

      _ref2 = str.dimensions.observation;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        dim = _ref2[i];
        if (codesInQuery[dim.id][obs[i]] == null) {
          return false;
        }
      }
      return true;
    };
    mapObservation = function(obs) {
      var dim, i, pos, _k, _l, _len2, _len3, _ref2, _ref3;

      _ref2 = str.dimensions.observation;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        dim = _ref2[i];
        componentValuesInResults[dim.id][obs[i]] = 1;
      }
      pos = str.dimensions.observation.length + 1;
      _ref3 = str.attributes.observation;
      for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
        dim = _ref3[i];
        if (obs[pos + i] == null) {
          continue;
        }
        componentValuesInResults[dim.id][obs[pos + i]] = 1;
      }
      return obs.slice();
    };
    rslt.dataSets = msg.dataSets.filter(filterDataSet).map(mapDataSetToResult);
    count = 0;
    for (key in componentValuesInResults) {
      value = componentValuesInResults[key];
      count += Object.keys(value).length;
    }
    if (count === 0) {
      response.statusCode = HTTP_NOT_FOUND;
      response.result.errors.push('Data not found');
      return;
    }
    for (key in componentValuesInResults) {
      value = componentValuesInResults[key];
      counter = 0;
      for (key2 in value) {
        value2 = value[key2];
        value[key2] = counter;
        counter += 1;
      }
    }
    rebaseArray = function(target, source, start) {
      var dim, i, pos, _k, _len2, _results;

      if (target == null) {
        return;
      }
      if (start == null) {
        start = 0;
      }
      _results = [];
      for (i = _k = 0, _len2 = source.length; _k < _len2; i = ++_k) {
        dim = source[i];
        pos = start + i;
        if (target[pos] == null) {
          continue;
        }
        _results.push(target[pos] = componentValuesInResults[dim.id][target[pos]]);
      }
      return _results;
    };
    rebaseObservation = function(obs) {
      rebaseArray(obs, str.dimensions.observation);
      return rebaseArray(obs, str.attributes.observation, str.dimensions.observation.length + 1);
    };
    rebaseDataSet = function(ds) {
      rebaseArray(ds.dimensions, str.dimensions.dataSet);
      rebaseArray(ds.attributes, str.attributes.dataSet);
      if (ds.observations != null) {
        return ds.observations.forEach(rebaseObservation);
      }
    };
    rslt.dataSets.forEach(rebaseDataSet);
    mapComponent = function(comp) {
      var mappedComp, _ref2;

      mappedComp = {
        id: comp.id,
        name: comp.name,
        description: comp.description,
        role: comp.role,
        values: []
      };
      _ref2 = componentValuesInResults[comp.id];
      for (key in _ref2) {
        value = _ref2[key];
        mappedComp.values[value] = comp.values[key];
      }
      return mappedComp;
    };
    rslt.structure = {
      id: msg.structure.id,
      href: msg.structure.href,
      ref: msg.structure.ref,
      dimensions: {},
      attributes: {},
      annotations: []
    };
    _ref2 = msg.structure.dimensions;
    for (key in _ref2) {
      components = _ref2[key];
      rslt.structure.dimensions[key] = components.map(mapComponent);
    }
    _ref3 = msg.structure.attributes;
    for (key in _ref3) {
      components = _ref3[key];
      rslt.structure.attributes[key] = components.map(mapComponent);
    }
    filterEmptyAttributes = function(value, i) {
      var k;

      if (i < (rslt.structure.dimensions.observation.length + 1)) {
        return true;
      }
      k = i - (rslt.structure.dimensions.observation.length + 1);
      return !emptyAttributes[k];
    };
    emptyAttributes = rslt.structure.attributes.observation.map(function(attr, i) {
      return attr.values.length === 0;
    });
    rslt.structure.attributes.observation = rslt.structure.attributes.observation.filter(function(a, i) {
      return !emptyAttributes[i];
    });
    rslt.dataSets.forEach(function(ds) {
      return ds.observations = ds.observations.map(function(o) {
        return o.filter(filterEmptyAttributes);
      });
    });
    findDimensionToGroup = function(dim, i) {
      var countNulls, nullCount;

      if (1 < dim.values.length) {
        return false;
      }
      countNulls = function(count, ds) {
        return count + ds.observations.reduce((function(c, o) {
          return c + (o[i] === null);
        }), 0);
      };
      nullCount = rslt.dataSets.reduce(countNulls, 0);
      if (0 < nullCount) {
        return false;
      }
      return true;
    };
    filterGrouppedDimensions = function(value, i) {
      if (dimGroupings.length < i) {
        return true;
      }
      return !dimGroupings[i];
    };
    groupDimensions = function(ds) {
      ds.dimensions = ds.dimensions.concat(dimGroupings.filter(function(g) {
        return g;
      }).map(function() {
        return 0;
      }));
      return ds.observations = ds.observations.map(function(o) {
        return o.filter(filterGrouppedDimensions);
      });
    };
    minObsCount = rslt.dataSets.map(function(d) {
      return d.observations.length;
    }).reduce(function(x, y) {
      if (x < y) {
        return x;
      } else {
        return y;
      }
    });
    if (1 < minObsCount) {
      dimGroupings = rslt.structure.dimensions.observation.map(findDimensionToGroup);
      rslt.structure.dimensions.dataSet = rslt.structure.dimensions.dataSet.concat(rslt.structure.dimensions.observation.filter(function(d, i) {
        return dimGroupings[i];
      }));
      rslt.structure.dimensions.observation = rslt.structure.dimensions.observation.filter(function(d, i) {
        return !dimGroupings[i];
      });
      rslt.dataSets.forEach(groupDimensions);
    }
    findAttributeToGroup = function(attr, i) {
      var countNulls, k, nullCount;

      if (1 < attr.values.length) {
        return false;
      }
      k = rslt.structure.dimensions.observation.length + 1 + i;
      countNulls = function(count, ds) {
        return count + ds.observations.reduce((function(c, o) {
          return c + (o[k] === null);
        }), 0);
      };
      nullCount = rslt.dataSets.reduce(countNulls, 0);
      if (0 < nullCount) {
        return false;
      }
      return true;
    };
    filterGrouppedAttributes = function(value, i) {
      var k;

      if (i < (rslt.structure.dimensions.observation.length + 1)) {
        return true;
      }
      k = i - (rslt.structure.dimensions.observation.length + 1);
      return !attrGroupings[k];
    };
    groupAttributes = function(ds) {
      ds.attributes = ds.attributes.concat(attrGroupings.filter(function(g) {
        return g;
      }).map(function() {
        return 0;
      }));
      return ds.observations = ds.observations.map(function(o) {
        return o.filter(filterGrouppedAttributes);
      });
    };
    attrGroupings = rslt.structure.attributes.observation.map(findAttributeToGroup);
    rslt.structure.attributes.dataSet = rslt.structure.attributes.dataSet.concat(rslt.structure.attributes.observation.filter(function(d, i) {
      return attrGroupings[i];
    }));
    rslt.structure.attributes.observation = rslt.structure.attributes.observation.filter(function(d, i) {
      return !attrGroupings[i];
    });
    rslt.dataSets.forEach(groupAttributes);
    switch (request.query.detail) {
      case 'serieskeysonly':
        dropDimension = 'TIME_PERIOD';
        pos = rslt.structure.dimensions.dataSet.map(function(d) {
          return d.id;
        }).indexOf(dropDimension);
        if (-1 < pos) {
          rslt.structure.dimensions.dataSet.splice(pos, 1);
          rslt.dataSets.forEach(function(ds) {
            return ds.dimensions.splice(pos, 1);
          });
        } else {
          pos = rslt.structure.dimensions.observation.map(function(d) {
            return d.id;
          }).indexOf(dropDimension);
          if (-1 < pos) {
            rslt.structure.dimensions.observation.splice(pos, 1);
            rslt.dataSets.forEach(function(ds) {
              return ds.observations.forEach(function(o) {
                return o.splice(pos, 1);
              });
            });
          }
        }
        rslt.structure.attributes.dataSet = [];
        rslt.structure.attributes.series = [];
        rslt.structure.attributes.observation = [];
        obsDimCount = rslt.structure.dimensions.observation.length;
        rslt.dataSets.forEach(function(ds) {
          return ds.attributes = [];
        });
        rslt.dataSets.forEach(function(ds) {
          return ds.observations = ds.observations.map(function(o) {
            return o.slice(0, obsDimCount);
          });
        });
        break;
      case 'dataonly':
        rslt.structure.attributes.dataSet = [];
        rslt.structure.attributes.series = [];
        rslt.structure.attributes.observation = [];
        obsDimCount = rslt.structure.dimensions.observation.length;
        rslt.dataSets.forEach(function(ds) {
          return ds.attributes = [];
        });
        rslt.dataSets.forEach(function(ds) {
          return ds.observations = ds.observations.map(function(o) {
            return o.slice(0, obsDimCount + 1);
          });
        });
        break;
      case 'nodata':
        pos = rslt.structure.dimensions.observation.length;
        rslt.dataSets.forEach(function(ds) {
          return ds.observations.forEach(function(o) {
            return o.splice(pos, 1);
          });
        });
    }
    if (dimAtObs !== 'AllDimensions') {
      obsDimCount = rslt.structure.dimensions.observation.length;
      pos = rslt.structure.dimensions.dataSet.map(function(d) {
        return d.id;
      }).indexOf(dimAtObs);
      if (-1 < pos) {
        rslt.structure.dimensions.series = rslt.structure.dimensions.observation;
        rslt.structure.dimensions.observation = rslt.structure.dimensions.dataSet.splice(pos, 1);
        formatDataSet = function(ds) {
          mapObservation = function(o) {
            return {
              dimensions: o.slice(0, obsDimCount),
              observations: [[0].concat(o.slice(obsDimCount))],
              attributes: []
            };
          };
          ds.series = ds.observations.map(mapObservation);
          return delete ds.observations;
        };
      } else {
        if (obsDimCount === 1) {
          rslt.structure.dimensions.observation = rslt.structure.dimensions.dataSet.concat(rslt.structure.dimensions.observation);
          rslt.structure.dimensions.dataSet = [];
          unGroupDataSetDimensions = function(ds) {
            ds.observations = ds.observations.map(function(o) {
              return ds.dimensions.concat(o);
            });
            return ds.dimensions = [];
          };
          rslt.dataSets.forEach(unGroupDataSetDimensions);
          obsDimCount = rslt.structure.dimensions.observation.length;
        }
        pos = rslt.structure.dimensions.observation.map(function(d) {
          return d.id;
        }).indexOf(dimAtObs);
        rslt.structure.dimensions.series = rslt.structure.dimensions.observation;
        rslt.structure.dimensions.observation = rslt.structure.dimensions.series.splice(pos, 1);
        formatDataSet = function(ds) {
          var attr, filterGrouppedObsAttributes, filterNotGrouppedObsAttributes, first, groupObsAttr, i, k, series, test, _k, _l, _len2, _len3, _len4, _m, _ref4, _results;

          series = {};
          mapObservation = function(o) {
            var obsDim, seriesDims, seriesKey, _ref4;

            seriesDims = o.slice(0, obsDimCount);
            obsDim = seriesDims.splice(pos, 1);
            seriesKey = seriesDims.join(KEY_SEPARATOR);
            if ((_ref4 = series[seriesKey]) == null) {
              series[seriesKey] = {
                dimensions: seriesDims,
                attributes: [],
                observations: [],
                annotations: []
              };
            }
            return series[seriesKey].observations.push(obsDim.concat(o.slice(obsDimCount)));
          };
          ds.observations.forEach(mapObservation);
          delete ds.observations;
          groupObsAttr = [];
          _ref4 = rslt.structure.attributes.observation;
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            attr = _ref4[_k];
            groupObsAttr.push(true);
          }
          for (key in series) {
            value = series[key];
            for (i = _l = 0, _len3 = groupObsAttr.length; _l < _len3; i = ++_l) {
              test = groupObsAttr[i];
              if (!(test === true)) {
                continue;
              }
              k = i + 2;
              first = value.observations[0][k];
              groupObsAttr[i] = value.observations.every(function(o) {
                return o[k] === first;
              });
            }
          }
          for (i = _m = 0, _len4 = groupObsAttr.length; _m < _len4; i = ++_m) {
            test = groupObsAttr[i];
            if (test === true) {
              rslt.structure.attributes.series.push(rslt.structure.attributes.observation[i]);
            }
          }
          filterGrouppedObsAttributes = function(v, i) {
            if (i < 2) {
              return false;
            }
            return groupObsAttr[i - 2];
          };
          filterNotGrouppedObsAttributes = function(v, i) {
            return !filterGrouppedObsAttributes(v, i);
          };
          for (key in series) {
            value = series[key];
            value.attributes = value.attributes.concat(value.observations[0].filter(filterGrouppedObsAttributes));
            value.observations = value.observations.map(function(o) {
              return o.filter(filterNotGrouppedObsAttributes);
            });
          }
          rslt.structure.attributes.observation = rslt.structure.attributes.observation.filter(function(a, i) {
            return !groupObsAttr[i];
          });
          ds.series = [];
          _results = [];
          for (key in series) {
            value = series[key];
            _results.push(ds.series.push({
              dimensions: value.dimensions,
              attributes: value.attributes,
              observations: value.observations
            }));
          }
          return _results;
        };
      }
      rslt.dataSets.forEach(formatDataSet);
    }
    obsDimCount = rslt.structure.dimensions.observation.length;
    if (rslt.structure.dimensions.series.length === 0) {
      addIndices = function(ds) {
        var observations;

        observations = {};
        ds.observations.forEach(function(o) {
          return observations[o.slice(0, obsDimCount).join(KEY_SEPARATOR)] = o.slice(obsDimCount);
        });
        return ds.observations = observations;
      };
    } else {
      addIndices = function(ds) {
        var addIndexToSeries, series;

        series = {};
        addIndexToSeries = function(s) {
          var observations;

          observations = {};
          s.observations.forEach(function(o) {
            return observations[o.slice(0, obsDimCount).join(KEY_SEPARATOR)] = o.slice(obsDimCount);
          });
          s.observations = observations;
          series[s.dimensions.join(KEY_SEPARATOR)] = s;
          return delete s.dimensions;
        };
        ds.series.forEach(addIndexToSeries);
        return ds.series = series;
      };
    }
    rslt.dataSets.forEach(addIndices);
    rslt.dataSets.forEach(function(ds) {
      return delete ds.dimensions;
    });
  };

  getDocs = function(request, response) {
    var docs, documentDataFlow, writeHTML;

    docs = {
      main: {
        Description: "Test server",
        Features: {
          Parameters: {
            dimensionAtObservation: 'Supported, you can use AllDimensions or any dimension id. Default is TIME_PERIOD',
            startPeriod: 'Supported, all time formats should work.',
            endPeriod: 'Supported, same as startPeriod.',
            firstNObservations: 'Not supported.',
            lastNObservations: 'Not supported.',
            detail: 'Supported, serieskeysonly, nodata, dataonly and full should work. Default is full.',
            updatedAfter: 'Not supported.'
          }
        },
        'Data Flows': {
          urls: ['docs/ECB_ICP1']
        }
      },
      ECB_ICP1: {
        Description: "Test data",
        Size: "",
        Requests: {
          'Data Flow': {
            Agency: 'ECB',
            Identifier: 'ECB_ICP1',
            Version: '1.0'
          },
          'Key Dimensions': {},
          'Time Dimension': {},
          'Data Provider': {
            Agency: 'ECB',
            Identifier: 'ECB'
          }
        },
        'Sample Requests': {
          urls: ['../data/ECB_ICP1/M.PT+FI.N.000000+071100.4.INX?startPeriod=2009-01&dimensionAtObservation=AllDimensions', '../data/ECB_ICP1/M.AT.N.000000.4.INX?startPeriod=2003-06', '../data/ECB_ICP1/M..N.0531_2.4.INX?startPeriod=2009-02&endPeriod=2009-02&dimensionAtObservation=REF_AREA', '../data/ECB_ICP1/M..N.0531_2.4.INX?startPeriod=2009-01&dimensionAtObservation=REF_AREA']
        }
      }
    };
    response.setHeader('Content-Type', 'text/html');
    writeHTML = function(values) {
      var body, objectToHTML;

      body = [];
      body.push('<!DOCTYPE html>');
      body.push('<html lang="en">');
      body.push('<head>');
      body.push('<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">');
      body.push('</head>');
      body.push('<body>');
      body.push('<div class="container">');
      body.push('<div class="page-header">');
      body.push('<h1>Documentation</h1>');
      body.push('</div>');
      objectToHTML = function(obj, level, index) {
        var count, heading, indexCur, key, link, value, _i, _len, _results;

        count = 1;
        heading = "h" + level;
        _results = [];
        for (key in obj) {
          value = obj[key];
          indexCur = index + count + '.';
          switch (key) {
            case 'urls':
              body.push('<ul>');
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                link = value[_i];
                body.push("<li><a href='" + link + "'>" + link + "</a></li>");
              }
              body.push('</ul>');
              break;
            default:
              if (key[0] === '<') {
                body.push(key);
              } else {
                body.push("<" + heading + ">" + indexCur + " " + key + "</" + heading + ">");
              }
              switch (typeof value) {
                case 'object':
                  objectToHTML(value, level + 1, "" + indexCur);
                  break;
                default:
                  if (value[0] === '<') {
                    body.push(value);
                  } else {
                    body.push("<p>" + value + "</p>");
                  }
              }
          }
          if (level === 2) {
            body.push('<hr>');
          }
          _results.push(count += 1);
        }
        return _results;
      };
      objectToHTML(values, 2, '');
      body.push('</div>');
      body.push('</body>');
      body.push('</html>');
      return body.join('');
    };
    documentDataFlow = function(id) {
      var comp, cube, cubeSize, dfDocs, full, html, key, obsCount, val, value, _i, _len, _ref;

      dfDocs = docs[id];
      if (dfDocs == null) {
        response.statusCode = HTTP_NOT_FOUND;
        return '<html>Not found</html>';
      }
      obsCount = dataset.dataSets.reduce((function(x, y) {
        return x + y.observations.length;
      }), 0);
      cubeSize = 1;
      cube = [];
      _ref = dataset.structure.dimensions;
      for (key in _ref) {
        value = _ref[key];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          comp = value[_i];
          html = [];
          html.push('<dl class="dl-horizontal">');
          html.push("<dt>ID</dt><dd>" + comp.id + "</dd>");
          html.push("<dt>Name</dt><dd>" + comp.name + "</dd>");
          html.push('<dt>Values</dt><dd>');
          html.push(((function() {
            var _j, _len1, _ref1, _results;

            _ref1 = comp.values;
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              val = _ref1[_j];
              _results.push("<abbr title='" + val.name + "'>" + val.id + "</abbr>");
            }
            return _results;
          })()).join(', '));
          html.push('</dd>');
          html.push('</dl>');
          cube.push(comp.values.length);
          cubeSize *= comp.values.length;
          if (comp.role === 'time') {
            dfDocs.Requests['Time Dimension'][comp.name] = html.join('');
          } else {
            dfDocs.Requests['Key Dimensions'][comp.name] = html.join('');
          }
        }
      }
      full = Math.round((obsCount / cubeSize) * 100);
      dfDocs.Size = "Total number of observations is " + obsCount + ". Total size of the dimensions space is ( " + (cube.join(' * ')) + " ) = " + cubeSize + ". Cube is " + full + "% full.";
      return writeHTML(dfDocs);
    };
    if (request.path[2] != null) {
      return documentDataFlow(request.path[2]);
    } else {
      return writeHTML(docs.main);
    }
  };

  validateRequest = function(request, response) {
    var auth, encoding, header, matches, mediaTypes, methods, parts, password, token, type, username, _i, _len;

    methods = ['GET', 'HEAD', 'OPTIONS'];
    mediaTypes = ['application/json', 'application/*', '*/*'];
    response.setHeader('Allow', methods.join(', '));
    response.setHeader('Access-Control-Allow-Methods', methods.join(', '));
    response.setHeader('Access-Control-Allow-Credentials', 'true');
    response.setHeader('Access-Control-Expose-Headers', 'X-Runtime, Content-Length');
    if (request.headers['origin'] != null) {
      response.setHeader('Access-Control-Allow-Origin', request.headers['origin']);
    } else {
      response.setHeader('Access-Control-Allow-Origin', '*');
    }
    if (methods.indexOf(request.method) === -1) {
      response.statusCode = HTTP_METHOD_NOT_ALLOWED;
      response.result.errors.push('Supported methods: ' + methods.join(', '));
      return;
    }
    if (request.headers['accept'] != null) {
      matches = 0;
      for (_i = 0, _len = mediaTypes.length; _i < _len; _i++) {
        type = mediaTypes[_i];
        matches += request.headers['accept'].indexOf(type) + 1;
      }
      if (matches === 0) {
        response.statusCode = HTTP_NOT_ACCEPTABLE;
        response.result.errors.push('Supported media types: ' + mediaTypes.join(','));
        return;
      }
    }
    encoding = request.headers['accept-encoding'];
    if (encoding != null) {
      if (encoding.match(/\bgzip\b/)) {
        response.setHeader('Content-Encoding', 'gzip');
      } else if (encoding.match(/\bdeflate\b/)) {
        response.setHeader('Content-Encoding', 'deflate');
      }
    }
    if (request.headers['access-control-request-headers'] != null) {
      response.setHeader('Access-Control-Allow-Headers', request.headers['access-control-request-headers']);
    }
    if (request.method === 'GET') {
      if (request.path[1] === 'auth') {
        request.path.shift();
        header = request.headers['authorization'] || '';
        token = header.split(/\s+/).pop() || '';
        auth = new Buffer(token, 'base64').toString();
        parts = auth.split(/:/);
        username = parts[0];
        password = parts[1];
        if (username !== 'test' || password !== 'test') {
          response.setHeader('WWW-Authenticate', 'BASIC realm="data/ECB,ECB_ICP1"');
          response.statusCode = HTTP_UNAUTHORIZED;
          response.result.errors.push('authorization required');
        }
      }
    }
  };

  compressResponse = function(request, response, body) {
    var sendResponse;

    sendResponse = function(err, body) {
      var encoding;

      if (err != null) {
        response.statusCode = HTTP_INTERNAL_SERVER_ERROR;
        response.end();
        return;
      }
      response.setHeader('X-Runtime', new Date() - response.start);
      if (body != null) {
        if (Buffer.isBuffer(body)) {
          response.setHeader('Content-Length', body.length);
        } else {
          response.setHeader('Content-Length', Buffer.byteLength(body));
        }
        if (request.method === 'GET') {
          response.end(body);
        } else {
          response.end();
        }
      } else {
        response.setHeader('Content-Length', 0);
        response.end();
      }
      encoding = response.getHeader('Content-Encoding');
      if (encoding == null) {
        encoding = '';
      }
      log("" + request.method + " " + request.url + " " + response.statusCode + " " + encoding);
    };
    switch (request.method) {
      case 'OPTIONS':
        return sendResponse();
      case 'GET':
      case 'HEAD':
        switch (response.getHeader('Content-Encoding')) {
          case 'deflate':
            return zlib.deflate(body, sendResponse);
          case 'gzip':
            return zlib.gzip(body, sendResponse);
          default:
            return sendResponse(void 0, body);
        }
    }
  };

  handleRequest = function(request, response) {
    var body, dataflow, protocol;

    response.start = new Date();
    response.setHeader('X-Powered-By', "Node.js/" + process.version);
    response.setHeader('Server', "" + SERVER_NAME + "/" + SERVER_VERSION + "/" + NODE_ENV);
    response.setHeader('Cache-Control', 'no-cache, no-store');
    response.setHeader('Pragma', 'no-cache');
    response.setHeader('Content-Language', 'en');
    response.statusCode = HTTP_OK;
    protocol = request.connection.encrypted != null ? 'https://' : 'http://';
    request.path = url.parse(request.url, false, false).pathname.split('/');
    validateRequest(request, response);
    switch (request.path[1]) {
      case 'data':
        response.setHeader('Content-Type', 'application/json');
        response.result = {
          'sdmx-proto-json': dataset['sdmx-proto-json'],
          header: {
            id: "IREF" + (process.hrtime()[0]) + (process.hrtime()[1]),
            test: NODE_ENV === 'production' ? false : true,
            prepared: (new Date()).toISOString(),
            sender: {
              id: SERVER_NAME,
              name: SERVER_NAME
            },
            request: {
              uri: "" + protocol + request.headers.host + request.url
            }
          },
          errors: []
        };
        if (request.url === '/data/ECB_ICP1/.....') {
          body = fs.readFileSync(FULL_RESPONSE_FILE);
        } else {
          if (response.statusCode === HTTP_OK) {
            parse(request, response);
          }
          if (response.statusCode === HTTP_OK) {
            dataflow = findDataFlow(request, response);
          }
          if (request.method === 'OPTIONS') {
            response.setHeader('Content-Length', 0);
          } else {
            if (response.statusCode === HTTP_OK) {
              query(dataflow, request, response);
            }
            if (response.statusCode === HTTP_OK) {
              response.result.header.name = dataset.header.name;
              response.result.errors = null;
            }
          }
          body = JSON.stringify(response.result);
        }
        break;
      case 'docs':
        if (request.method === 'OPTIONS') {
          response.setHeader('Content-Length', 0);
        } else {
          body = getDocs(request, response);
        }
    }
    return compressResponse(request, response, body);
  };

  test = function() {
    var req, res;

    res = {
      headers: [],
      setHeader: function(n, v) {
        return this.headers[n] = v;
      },
      getHeader: function(n) {
        return this.headers[n];
      },
      end: function() {}
    };
    req = {
      method: 'GET',
      url: '/data/ECB_ICP1/M.PT+FI.N.073000.4.INX?startPeriod=2009&endPeriod=2009&dimensionAtObservation=AllDimensions',
      headers: {
        accept: 'application/json'
      }
    };
    return handleRequest(req, res);
  };

  log('starting');

  dataset = loadDataset(path.join(path.dirname(fs.realpathSync(__filename)), DATA_FILE));

  server = http.createServer(handleRequest).listen(PORT_NUMBER);

  log("listening on port " + PORT_NUMBER);

  if (NODE_ENV === 'production') {
    log('Warning: This server is not designed for a production environment');
  }

}).call(this);
