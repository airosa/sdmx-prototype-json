// Generated by CoffeeScript 1.6.2
(function() {
  var DATA_FILE, PORT_NUMBER, SERVER_NAME, SERVER_VERSION, addCodesToQuery, calculateIndexMultipliers, compressResponse, dataset, filterTimePeriods, findDataFlow, fs, handleRequest, http, loadDataset, log, parse, parseDataQuery, parseDate, parseFlowRef, parseKey, parseProviderRef, parseQueryParams, preProcessMessage, query, test, timePeriodToDate, url, validateRequest, zlib,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  url = require('url');

  fs = require('fs');

  zlib = require('zlib');

  SERVER_NAME = 'LIVE-TEST-WS-3';

  SERVER_VERSION = '0.5.0';

  PORT_NUMBER = process.env.PORT || 8081;

  DATA_FILE = 'hicp-coicop-inx-json-slice.json';

  dataset = null;

  log = function(msg) {
    return console.log("" + (new Date().toTimeString().slice(0, 8)) + " " + msg);
  };

  calculateIndexMultipliers = function(dimensions) {
    var dim, i, multipliers, prev, reversedDimensions, _i, _len;

    multipliers = new Array(dimensions.length);
    reversedDimensions = dimensions.slice().reverse();
    prev = 1;
    for (i = _i = 0, _len = reversedDimensions.length; _i < _len; i = ++_i) {
      dim = reversedDimensions[i];
      multipliers[i] = prev;
      prev = dim.length * prev;
    }
    return multipliers.reverse();
  };

  loadDataset = function(filename) {
    var jsonString, msg;

    jsonString = fs.readFileSync(filename);
    msg = JSON.parse(jsonString);
    return preProcessMessage(msg);
  };

  preProcessMessage = function(msg) {
    var array, attrs, comp, compId, dims, ext, field, filterDataSet, i, key, pkg, pkgFields, value, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

    pkgFields = ['dataSetDimensions', 'seriesDimensions', 'observationDimensions', 'dataSetAttributes', 'seriesAttributes', 'observationAttributes'];
    ext = (_ref = (_base = msg.structure).extensions) != null ? _ref : _base.extensions = {};
    pkg = msg.structure.packaging;
    for (_i = 0, _len = pkgFields.length; _i < _len; _i++) {
      field = pkgFields[_i];
      if ((_ref1 = pkg[field]) == null) {
        pkg[field] = [];
      }
    }
    ext.componentMap = {};
    _ref2 = msg.structure.components;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      comp = _ref2[_j];
      ext.componentMap[comp.id] = comp;
      if (comp.id === 'TIME_PERIOD') {
        ext.timeDimension = comp;
      }
    }
    dims = [];
    attrs = [];
    for (key in pkg) {
      value = pkg[key];
      array = /Dimensions/.test(key) ? dims : attrs;
      for (i = _k = 0, _len2 = value.length; _k < _len2; i = ++_k) {
        compId = value[i];
        value[i] = ext.componentMap[compId];
        array.push(compId);
      }
    }
    ext.keyDimensions = [];
    ext.attributeMap = {};
    _ref3 = msg.structure.components;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      comp = _ref3[_l];
      if ((_ref4 = comp.id, __indexOf.call(dims, _ref4) >= 0) && comp.id !== 'TIME_PERIOD') {
        ext.keyDimensions.push(comp);
      }
      if (_ref5 = comp.id, __indexOf.call(attrs, _ref5) >= 0) {
        ext.attributeMap[comp.id] = comp;
      }
    }
    if (msg.dataSets != null) {
      filterDataSet = function(dataSet) {
        var groups, joinGroupAttributes;

        groups = dataSet.series.filter(function(series) {
          return series.observations == null;
        });
        dataSet.series = dataSet.series.filter(function(series) {
          return series.observations != null;
        });
        joinGroupAttributes = function(series) {
          var matchSeries;

          matchSeries = function(group) {
            var attr, dim, _len4, _len5, _m, _n, _ref6, _ref7, _results;

            _ref6 = group.dimensions;
            for (i = _m = 0, _len4 = _ref6.length; _m < _len4; i = ++_m) {
              dim = _ref6[i];
              if (dim !== null) {
                if (dim !== series.dimensions[i]) {
                  return;
                }
              }
            }
            _ref7 = group.attributes;
            _results = [];
            for (i = _n = 0, _len5 = _ref7.length; _n < _len5; i = ++_n) {
              attr = _ref7[i];
              if (attr !== null) {
                _results.push(series.attributes[i] = attr);
              }
            }
            return _results;
          };
          return groups.forEach(matchSeries);
        };
        return dataSet.series.forEach(joinGroupAttributes);
      };
      msg.dataSets.forEach(filterDataSet);
    }
    return msg;
  };

  exports.timePeriodToDate = timePeriodToDate = function(frequency, year, period, end) {
    var date;

    if (year % 1 !== 0) {
      return null;
    }
    if (period % 1 !== 0) {
      return null;
    }
    if (period < 1) {
      return null;
    }
    date = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
    if (!end) {
      period = period - 1;
    }
    switch (frequency) {
      case 'A':
        if (1 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (12 * period));
        break;
      case 'S':
        if (2 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (6 * period));
        break;
      case 'T':
        if (3 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (4 * period));
        break;
      case 'Q':
        if (4 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (3 * period));
        break;
      case 'M':
        if (12 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + period);
        break;
      case 'W':
        if (53 < period) {
          return null;
        }
        if (date.getUTCDay() !== 4) {
          date.setUTCMonth(0, 1 + (((4 - date.getUTCDay()) + 7) % 7));
        }
        date.setUTCDate(date.getUTCDate() - 3);
        date.setUTCDate(date.getUTCDate() + (7 * period));
        break;
      case 'D':
        if (366 < period) {
          return null;
        }
        date.setUTCDate(date.getUTCDate() + period);
        break;
      default:
        return null;
    }
    return date;
  };

  exports.parseDate = parseDate = function(value, end) {
    var date, millisecs;

    date = null;
    if (/^\d\d\d\d-[A|S|T|Q]\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value[6], end);
    } else if (/^\d\d\d\d-[M|W]\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 8), end);
    } else if (/^\d\d\d\d-D\d\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 9), end);
    } else {
      millisecs = Date.parse(value);
      if (isNaN(millisecs)) {
        return null;
      }
      date = new Date(millisecs);
      if (end) {
        switch (value.length) {
          case 4:
            date.setUTCFullYear(date.getUTCFullYear() + 1);
            break;
          case 7:
            date.setUTCMonth(date.getUTCMonth() + 1);
            break;
          case 10:
            date.setUTCDate(date.getUTCDate() + 1);
        }
      }
    }
    if ((date != null) && end) {
      date.setUTCSeconds(date.getUTCSeconds() - 1);
    }
    return date;
  };

  exports.parseFlowRef = parseFlowRef = function(flowRefStr, request, response) {
    var flowRef, regex;

    if (flowRefStr == null) {
      response.result.errors.push('Mandatory parameter flowRef is missing');
      response.statusCode = 400;
      return;
    }
    regex = /^(([A-z0-9_@$\-]+)|(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*)(\,[A-z0-9_@$\-]+)(\,(latest|([0-9]+(\.[0-9]+)*)))?))$/;
    if (!regex.test(flowRefStr)) {
      response.result.errors.push("Invalid parameter flowRef " + flowRefStr);
      response.statusCode = 400;
      return;
    }
    flowRef = flowRefStr.split(',');
    if (flowRef.length === 1) {
      flowRef[1] = flowRef[0];
      flowRef[0] = 'all';
    }
    if ((flowRef[2] == null) || flowRef[2] === '') {
      flowRef[2] = 'latest';
    }
    return request.query.flowRef = {
      agencyID: flowRef[0],
      id: flowRef[1],
      version: flowRef[2]
    };
  };

  exports.parseKey = parseKey = function(keyStr, request, response) {
    var code, codes, dim, dims, i, key, regex, _i, _j, _len, _len1;

    if (keyStr == null) {
      keyStr = 'all';
    }
    if (keyStr === 'all') {
      request.query.key = 'all';
      return;
    }
    regex = /^(([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?([.]([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?)*)$/;
    if (!regex.test(keyStr)) {
      response.result.errors.push("Invalid parameter flowRef " + keyStr);
      response.statusCode = 400;
      return;
    }
    key = [];
    dims = keyStr.split('.');
    for (i = _i = 0, _len = dims.length; _i < _len; i = ++_i) {
      dim = dims[i];
      codes = dim.split('+');
      key[i] = [];
      for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
        code = codes[_j];
        if (code !== '') {
          key[i].push(code);
        }
      }
      if (-1 < dim.indexOf('+') && key[i].length === 0) {
        response.result.errors.push("Invalid parameter key " + keyStr);
        response.statusCode = 400;
        return;
      }
    }
    return request.query.key = key;
  };

  exports.parseProviderRef = parseProviderRef = function(providerRefStr, request, response) {
    var providerRef, regex;

    if (providerRefStr == null) {
      providerRefStr = 'all';
    }
    regex = /^(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*\,)?([A-z0-9_@$\-]+))$/;
    if (!regex.test(providerRefStr)) {
      response.result.errors.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = 400;
      return;
    }
    providerRef = providerRefStr.split(',');
    switch (providerRef.length) {
      case 1:
        if (providerRef[0] !== 'all') {
          providerRef[1] = providerRef[0];
          providerRef[0] = 'all';
        }
    }
    if ((providerRef[0] == null) || providerRef[0] === '') {
      providerRef[0] = 'all';
    }
    if ((providerRef[1] == null) || providerRef[1] === '') {
      providerRef[1] = 'all';
    }
    if (providerRef.length !== 2) {
      response.result.errors.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = 400;
      return;
    }
    return request.query.providerRef = {
      agencyID: providerRef[0],
      id: providerRef[1]
    };
  };

  exports.parseQueryParams = parseQueryParams = function(request, response) {
    var date, param, parameters, value;

    parameters = url.parse(request.url, true, false).query;
    for (param in parameters) {
      value = parameters[param];
      switch (param) {
        case 'startPeriod':
        case 'endPeriod':
          date = parseDate(value, param === 'endPeriod');
          if (date != null) {
            request.query[param] = date;
            continue;
          }
          break;
        case 'firstNObservations':
        case 'lastNObservations':
          if (0 < +value) {
            request.query[param] = +value;
            continue;
          }
          break;
        case 'updatedAfter':
          response.statusCode = 501;
          return;
        case 'dimensionAtObservation':
          request.query[param] = value;
          continue;
        case 'detail':
          switch (value) {
            case 'full':
            case 'dataonly':
            case 'nodata':
            case 'serieskeysonly':
              request.query[param] = value;
              continue;
          }
      }
      response.result.errors.push("Invalid query parameter " + param + " value " + value);
      response.statusCode = 400;
      return;
    }
  };

  parseDataQuery = function(path, request, response) {
    parseFlowRef(path[2], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseKey(path[3], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseProviderRef(path[4], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseQueryParams(request, response);
    if (response.statusCode !== 200) {

    }
  };

  parse = function(request, response) {
    var path;

    request.query = {};
    path = url.parse(request.url, false, false).pathname.split('/');
    if (path[1] === 'auth') {
      path.shift();
    }
    request.query.resource = path[1];
    switch (request.query.resource) {
      case 'data':
        return parseDataQuery(path, request, response);
      default:
        response.statusCode = 501;
    }
  };

  findDataFlow = function(request, response) {
    var found;

    found = true;
    found &= (function() {
      switch (request.query.flowRef.agencyID) {
        case 'all':
        case 'ECB':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.id) {
        case 'ECB_ICP1':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.version) {
        case 'latest':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.agencyID) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.id) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    if (!found) {
      response.statusCode = 404;
      response.result.errors.push("Data flow not found");
      return;
    }
    return dataset;
  };

  filterTimePeriods = function(request, query, timeDimension) {
    var endDate, j, period, periods, startDate, _i, _len, _ref;

    periods = {};
    _ref = timeDimension.values;
    for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
      period = _ref[j];
      if (request.query.startPeriod != null) {
        startDate = parseDate(period.id, false);
        if (!(request.query.startPeriod <= startDate)) {
          continue;
        }
      }
      if (request.query.endPeriod != null) {
        endDate = parseDate(period.id, true);
        if (!(endDate <= request.query.endPeriod)) {
          continue;
        }
      }
      periods[j] = 1;
    }
    return query[timeDimension.id] = periods;
  };

  addCodesToQuery = function(request, response, query, msg) {
    var code, codeMap, codePositions, dim, i, j, key, keyCodes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3;

    key = msg.structure.extensions.keyDimensions;
    codePositions = {};
    if (request.query.key === 'all') {
      for (_i = 0, _len = key.length; _i < _len; _i++) {
        dim = key[_i];
        _ref = dim.values;
        for (j = _j = 0, _len1 = _ref.length; _j < _len1; j = ++_j) {
          code = _ref[j];
          codePositions[j] = 1;
        }
        query[dim.id] = codePositions;
      }
      return query;
    }
    if (request.query.key.length !== key.length) {
      response.result.errors.push("Invalid number of dimensions in parameter key");
      response.statusCode = 400;
      return;
    }
    _ref1 = request.query.key;
    for (i = _k = 0, _len2 = _ref1.length; _k < _len2; i = ++_k) {
      keyCodes = _ref1[i];
      dim = key[i];
      codePositions = {};
      if (keyCodes.length === 0) {
        _ref2 = dim.values;
        for (j = _l = 0, _len3 = _ref2.length; _l < _len3; j = ++_l) {
          code = _ref2[j];
          codePositions[j] = 1;
        }
        query[dim.id] = codePositions;
        continue;
      }
      codeMap = {};
      _ref3 = dim.values;
      for (j = _m = 0, _len4 = _ref3.length; _m < _len4; j = ++_m) {
        code = _ref3[j];
        codeMap[code.id] = j;
      }
      for (_n = 0, _len5 = keyCodes.length; _n < _len5; _n++) {
        code = keyCodes[_n];
        codePositions[codeMap[code] != null ? codeMap[code] : -1] = 1;
      }
      query[dim.id] = codePositions;
    }
    return query;
  };

  query = function(msg, request, response) {
    var attrId, attributesInResults, code, codeCounts, codesInQuery, codesWithData, comp, compIdMap, componentValuesInResults, compressDataSet, counter, dim, filterDataSet, filterObservations, filterSeries, filterTime, filtered, formatDataSet, i, isInQuery, isInQueryTime, key, key2, mapComponent, mapDataSetToResult, mapSeries, newObs, newPos, noAttributes, noObservations, obj, obj2, obs, obsCount, obsDimPos, observations, pos, reIndexArray, reIndexDataSet, reIndexObservations, reIndexSeries, resultDataSets, resultObj, results, results2, rslt, value, value2, _i, _j, _k, _l, _len, _len1, _len10, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _s;

    rslt = response.result;
    codesInQuery = {};
    filterTime = (request.query.startPeriod != null) || (request.query.endPeriod != null);
    if (filterTime) {
      filterTimePeriods(request, codesInQuery, msg.structure.extensions.timeDimension);
    }
    addCodesToQuery(request, response, codesInQuery, msg);
    if (response.statusCode !== 200) {
      return;
    }
    noObservations = false;
    noAttributes = false;
    switch (request.query.detail) {
      case 'serieskeysonly':
        noObservations = false;
        noAttributes = true;
        break;
      case 'dataonly':
        noAttributes = true;
        break;
      case 'nodata':
        noObservations = true;
    }
    componentValuesInResults = {};
    _ref = msg.structure.components;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comp = _ref[_i];
      componentValuesInResults[comp.id] = {};
    }
    filterDataSet = function(dataSet) {
      var dimId, i, value, _j, _k, _len1, _len2, _ref1, _ref2;

      if (dataSet.dataSetAction === 'Delete') {
        return false;
      }
      if (msg.structure.packaging.dataSetDimensions == null) {
        return true;
      }
      if (msg.structure.packaging.dataSetDimensions.length === 0) {
        return true;
      }
      _ref1 = dataSet.dimensions;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        value = _ref1[i];
        dimId = msg.structure.packaging.dataSetDimensions[i].id;
        if (codesInQuery[dimId][value] == null) {
          return false;
        }
        componentValuesInResults[dimId][value] = 1;
      }
      _ref2 = dataSet.attributes;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        value = _ref2[i];
        dimId = msg.structure.packaging.dataSetAttributes[i].id;
        componentValuesInResults[dimId][value] = 1;
      }
      return true;
    };
    filterSeries = function(series) {
      var dimId, i, value, _j, _k, _len1, _len2, _ref1, _ref2;

      if (series.observations == null) {
        return false;
      }
      _ref1 = series.dimensions;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        value = _ref1[i];
        dimId = msg.structure.packaging.seriesDimensions[i].id;
        if (codesInQuery[dimId][value] == null) {
          return false;
        }
        componentValuesInResults[dimId][value] = 1;
      }
      _ref2 = series.attributes;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        value = _ref2[i];
        if (value == null) {
          continue;
        }
        dimId = msg.structure.packaging.seriesAttributes[i].id;
        componentValuesInResults[dimId][value] = 1;
      }
      return true;
    };
    filterObservations = function(obs) {
      var dim, i, pos, _j, _k, _len1, _len2, _ref1, _ref2;

      _ref1 = msg.structure.packaging.observationDimensions;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        dim = _ref1[i];
        if (codesInQuery[dim.id][obs[i]] == null) {
          return false;
        }
        componentValuesInResults[dim.id][obs[i]] = 1;
      }
      pos = msg.structure.packaging.observationDimensions.length + 1;
      _ref2 = msg.structure.packaging.observationAttributes;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        dim = _ref2[i];
        if (obs[pos + i] == null) {
          continue;
        }
        componentValuesInResults[dim.id][obs[pos + i]] = 1;
      }
      return true;
    };
    mapSeries = function(series) {
      var result;

      result = {
        dimensions: series.dimensions.slice(),
        attributes: series.attributes.slice(),
        observations: series.observations.filter(filterObservations).map(function(obs) {
          return obs.slice();
        })
      };
      return result;
    };
    mapDataSetToResult = function(dataSet) {
      var result;

      result = {
        dataSetID: dataSet.dataSetID,
        dataSetAction: dataSet.dataSetAction,
        extracted: dataSet.extracted,
        dimensions: dataSet.dimensions,
        attributes: dataSet.attributes
      };
      if (dataSet.series != null) {
        result.series = dataSet.series.filter(filterSeries).map(mapSeries);
      }
      if (dataSet.observations != null) {
        result.observations = dataSet.observations.filter(filterObservations);
      }
      return result;
    };
    formatDataSet = function(dataSet) {
      return dataSet;
    };
    compressDataSet = function(dataSet) {
      return dataSet;
    };
    resultDataSets = msg.dataSets.filter(filterDataSet).map(mapDataSetToResult).map(formatDataSet).map(compressDataSet);
    rslt.dataSets = resultDataSets;
    for (key in componentValuesInResults) {
      value = componentValuesInResults[key];
      counter = 0;
      for (key2 in value) {
        value2 = value[key2];
        value[key2] = counter;
        counter += 1;
      }
    }
    reIndexArray = function(array, pkg, start) {
      var dim, i, _j, _len1, _ref1, _results;

      if (array == null) {
        return;
      }
      if (start == null) {
        start = 0;
      }
      _ref1 = msg.structure.packaging[pkg];
      _results = [];
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        dim = _ref1[i];
        if (array[start + i] == null) {
          continue;
        }
        _results.push(array[start + i] = componentValuesInResults[dim.id][array[start + i]]);
      }
      return _results;
    };
    reIndexObservations = function(obs) {
      var start;

      reIndexArray(obs, 'observationDimensions');
      start = msg.structure.packaging.observationDimensions.length + 1;
      reIndexArray(obs, 'observationAttributes', start);
      return obs;
    };
    reIndexSeries = function(series) {
      reIndexArray(series.dimensions, 'seriesDimensions');
      reIndexArray(series.attributes, 'seriesAttributes');
      series.observations = series.observations.map(reIndexObservations);
      return series;
    };
    reIndexDataSet = function(dataSet) {
      reIndexArray(dataSet.dimensions, 'dataSetDimensions');
      reIndexArray(dataSet.attributes, 'dataSetAttributes');
      if (dataSet.series != null) {
        dataSet.series = dataSet.series.map(reIndexSeries);
      }
      if (dataSet.observations != null) {
        dataSet.observations = dataSet.observations.map(reIndexObservations);
      }
      return dataSet;
    };
    rslt.dataSets = rslt.dataSets.map(reIndexDataSet);
    mapComponent = function(comp) {
      var resultComp, _ref1;

      resultComp = {
        id: comp.id,
        name: comp.name,
        description: comp.description,
        role: comp.role,
        values: []
      };
      _ref1 = componentValuesInResults[comp.id];
      for (key in _ref1) {
        value = _ref1[key];
        resultComp.values[value] = comp.values[key];
      }
      return resultComp;
    };
    rslt.structure = {
      id: msg.structure.id,
      href: msg.structure.href,
      packaging: {},
      components: msg.structure.components.map(mapComponent)
    };
    compIdMap = {};
    rslt.structure.components.forEach(function(comp) {
      return compIdMap[comp.id] = comp;
    });
    _ref1 = msg.structure.packaging;
    for (key in _ref1) {
      value = _ref1[key];
      rslt.structure.packaging[key] = value.map(function(comp) {
        return compIdMap[comp.id];
      });
    }
    _ref2 = rslt.structure.packaging;
    for (key in _ref2) {
      value = _ref2[key];
      rslt.structure.packaging[key] = value.map(function(comp) {
        return comp.id;
      });
    }
    return;
    isInQuery = function(obj) {
      var code, i, _j, _len1, _ref3;

      _ref3 = obj.dimensions;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        code = _ref3[i];
        if (code === null) {
          continue;
        }
        if (codesInQuery[i].length === 0) {
          continue;
        }
        if (-1 < codesInQuery[i].indexOf(code)) {
          continue;
        }
        return false;
      }
      return true;
    };
    isInQueryTime = function(obs) {
      if (-1 < timeCodes.indexOf(obs[0])) {
        return true;
      }
      return false;
    };
    filtered = msg.data.filter(isInQuery);
    codesWithData = [];
    codeCounts = [];
    _ref3 = msg.dimensions.id;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      dim = _ref3[_j];
      codesWithData.push({});
      codeCounts.push(0);
    }
    obsDimPos = msg.dimensions[msg.dimensions.dimensionAtObservation].index;
    obsCount = 0;
    results = [];
    for (_k = 0, _len2 = filtered.length; _k < _len2; _k++) {
      obj = filtered[_k];
      resultObj = {
        dimensions: [],
        attributes: noAttributes ? void 0 : obj.attributes
      };
      if (obj.dimensions != null) {
        _ref4 = obj.dimensions;
        for (i = _l = 0, _len3 = _ref4.length; _l < _len3; i = ++_l) {
          code = _ref4[i];
          if (code != null) {
            if (codesWithData[i][code] == null) {
              codesWithData[i][code] = codeCounts[i];
              codeCounts[i] += 1;
            }
            resultObj.dimensions.push(codesWithData[i][code]);
          } else {
            resultObj.dimensions.push(code);
          }
        }
      }
      if (noObservations || (obj.observations == null)) {
        results.push(resultObj);
        continue;
      }
      if (filterTime) {
        observations = obj.observations.filter(isInQueryTime);
      } else {
        observations = obj.observations;
      }
      resultObj.observations = [];
      counter = 0;
      for (_m = 0, _len4 = observations.length; _m < _len4; _m++) {
        obs = observations[_m];
        counter += 1;
        if (request.query.lastNObservations != null) {
          if (!(observations.length - counter + 1 <= request.query.lastNObservations)) {
            continue;
          }
        }
        newObs = obs.slice();
        if (codesWithData[obsDimPos][obs[0]] == null) {
          codesWithData[obsDimPos][obs[0]] = codeCounts[obsDimPos];
          codeCounts[obsDimPos] += 1;
        }
        newObs[0] = codesWithData[obsDimPos][obs[0]];
        resultObj.observations.push(newObs);
        obsCount += 1;
        if (request.query.firstNObservations != null) {
          if (request.query.firstNObservations === counter) {
            break;
          }
        }
      }
      if (!(0 < resultObj.observations.length)) {
        continue;
      }
      results.push(resultObj);
    }
    if (obsCount === 0) {
      response.statusCode = 404;
      response.result.errors.push('Observations not found');
      return;
    }
    rslt.dimensions = {
      id: msg.dimensions.id,
      dimensionAtObservation: request.query.dimensionAtObservation
    };
    _ref5 = msg.dimensions.id;
    for (i = _n = 0, _len5 = _ref5.length; _n < _len5; i = ++_n) {
      dim = _ref5[i];
      rslt.dimensions[dim] = {
        id: msg.dimensions[dim].id,
        codes: [],
        name: msg.dimensions[dim].name,
        type: msg.dimensions[dim].type,
        index: i
      };
      _ref6 = codesWithData[i];
      for (pos in _ref6) {
        newPos = _ref6[pos];
        code = msg.dimensions[dim].codes.id[pos];
        rslt.dimensions[dim].codes[newPos] = {
          index: newPos,
          id: msg.dimensions[dim].codes[code].id,
          name: msg.dimensions[dim].codes[code].name,
          order: pos
        };
        if (msg.dimensions[dim].codes[code].start != null) {
          rslt.dimensions[dim].codes[newPos].start = msg.dimensions[dim].codes[code].start;
        }
        if (msg.dimensions[dim].codes[code].end != null) {
          rslt.dimensions[dim].codes[newPos].end = msg.dimensions[dim].codes[code].end;
        }
      }
    }
    if (request.query.detail === 'serieskeysonly') {
      return;
    }
    if (rslt.dimensions.dimensionAtObservation !== msg.dimensions.dimensionAtObservation) {
      if (rslt.dimensions.dimensionAtObservation === 'AllDimensions') {
        results2 = [];
        for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
          obj = results[_o];
          if (obj.observations == null) {
            results2.push(obj);
            continue;
          }
          obj2 = {
            dimensions: [],
            attributes: obj.attributes,
            observations: []
          };
          _ref7 = obj.observations;
          for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
            obs = _ref7[_p];
            obj2.observations.push(obj.dimensions.concat(obs));
          }
          results2.push(obj2);
        }
        results = results2;
      } else {
        response.statusCode = 501;
        response.result.errors.push('Supported dimensionAtObservation values: TIME_PERIOD, AllDimensions');
        return;
      }
    }
    /*
        # We need to pivot the measure array into subarrays
    
        if rslt.dimensions.dimensionAtObservation is 'AllDimensions'
            pivotedResults = []
            for obj in results
                dims = obj.dimensions
                obj2 = {}
    
    
        pivot = []
        pivotDimPos = rslt.dimensions.id.indexOf rslt.dimensions.dimensionAtObservation
        resultCodeLengths = []
        pivotMultipliers = []
        pivotCount = 1
        for dim, n in rslt.dimensions.id
            resultCodeLengths.push rslt.dimensions[dim].codes.id.length
            continue if n is pivotDimPos
            pivotMultipliers[n] = pivotCount
            pivotCount *= rslt.dimensions[dim].codes.id.length
    
        # magic loop
        for i in [0..resultCount-1]
            obsIndex = 0
            pivotIndex = 0
            pivotSubIndex = 0
            for length, n in resultCodeLengths
                codeIndex = Math.floor( i / resultMultipliers[n] ) % length
                obsIndex += codeIndex * resultMultipliers[n]
    
                if n is pivotDimPos
                    pivotSubIndex = codeIndex
                else
                    pivotIndex += codeIndex * pivotMultipliers[n]
    
            if msg.measure[obsIndex]?
                pivot[pivotIndex] ?= []
                pivot[pivotIndex][pivotSubIndex] = rslt.measure[obsIndex]
    
        rslt.measure = pivot
    */

    rslt.data = results;
    if (noAttributes) {
      return;
    }
    attributesInResults = {};
    for (_q = 0, _len8 = results.length; _q < _len8; _q++) {
      obj = results[_q];
      if (obj.attributes == null) {
        continue;
      }
      for (attrId in obj.attributes) {
        attributesInResults[attrId] = null;
      }
    }
    _ref8 = msg.attributes.obsAttributes;
    for (_r = 0, _len9 = _ref8.length; _r < _len9; _r++) {
      attrId = _ref8[_r];
      attributesInResults[attrId] = null;
    }
    rslt.attributes = {
      id: [],
      obsAttributes: msg.attributes.obsAttributes
    };
    _ref9 = Object.keys(attributesInResults);
    _results = [];
    for (_s = 0, _len10 = _ref9.length; _s < _len10; _s++) {
      attrId = _ref9[_s];
      rslt.attributes.id.push(attrId);
      _results.push(rslt.attributes[attrId] = {
        id: msg.attributes[attrId].id,
        name: msg.attributes[attrId].name,
        mandatory: msg.attributes[attrId].mandatory,
        "default": msg.attributes[attrId]["default"],
        codes: msg.attributes[attrId].codes
      });
    }
    return _results;
  };

  validateRequest = function(request, response) {
    var auth, encoding, header, matches, mediaTypes, methods, parts, password, path, token, type, username, _i, _len;

    methods = ['GET', 'HEAD', 'OPTIONS'];
    mediaTypes = ['application/json', 'application/*', '*/*'];
    response.setHeader('Allow', methods.join(', '));
    response.setHeader('Access-Control-Allow-Methods', methods.join(', '));
    response.setHeader('Access-Control-Allow-Credentials', 'true');
    if (request.headers['origin'] != null) {
      response.setHeader('Access-Control-Allow-Origin', request.headers['origin']);
    } else {
      response.setHeader('Access-Control-Allow-Origin', '*');
    }
    if (methods.indexOf(request.method) === -1) {
      response.statusCode = 405;
      response.result.errors.push('Supported methods: ' + methods.join(', '));
      return;
    }
    if (request.headers['accept'] != null) {
      matches = 0;
      for (_i = 0, _len = mediaTypes.length; _i < _len; _i++) {
        type = mediaTypes[_i];
        matches += request.headers['accept'].indexOf(type) + 1;
      }
      if (matches === 0) {
        response.statusCode = 406;
        response.result.errors.push('Supported media types: ' + mediaTypes.join(','));
        return;
      }
    }
    encoding = request.headers['accept-encoding'];
    if (encoding != null) {
      if (encoding.match(/\bdeflate\b/)) {
        response.setHeader('Content-Encoding', 'deflate');
      } else if (encoding.match(/\bgzip\b/)) {
        response.setHeader('Content-Encoding', 'gzip');
      }
    }
    if (request.headers['access-control-request-headers'] != null) {
      response.setHeader('Access-Control-Allow-Headers', request.headers['access-control-request-headers']);
    }
    if (request.method === 'GET') {
      path = url.parse(request.url, false, false).pathname.split('/');
      if (path[1] === 'auth') {
        header = request.headers['authorization'] || '';
        token = header.split(/\s+/).pop() || '';
        auth = new Buffer(token, 'base64').toString();
        parts = auth.split(/:/);
        username = parts[0];
        password = parts[1];
        if (username !== 'test' || password !== 'test') {
          response.setHeader('WWW-Authenticate', 'BASIC realm="data/ECB,ECB_ICP1"');
          response.statusCode = 401;
          response.result.errors.push('authorization required');
        }
      }
    }
  };

  compressResponse = function(request, response) {
    var body, sendResponse;

    sendResponse = function(err, body) {
      var encoding;

      if (err != null) {
        response.statusCode = 500;
        response.end();
        return;
      }
      response.setHeader('X-Runtime', new Date() - response.start);
      if (body != null) {
        if (Buffer.isBuffer(body)) {
          response.setHeader('Content-Length', body.length);
        } else {
          response.setHeader('Content-Length', Buffer.byteLength(body));
        }
        if (request.method === 'GET') {
          response.end(body);
        } else {
          response.end();
        }
      } else {
        response.setHeader('Content-Length', 0);
        response.end();
      }
      encoding = response.getHeader('Content-Encoding');
      if (encoding == null) {
        encoding = '';
      }
      log("" + request.method + " " + request.url + " " + response.statusCode + " " + encoding);
    };
    switch (request.method) {
      case 'OPTIONS':
        return sendResponse();
      case 'GET':
      case 'HEAD':
        body = JSON.stringify(response.result, null, 2);
        switch (response.getHeader('Content-Encoding')) {
          case 'deflate':
            return zlib.deflate(body, sendResponse);
          case 'gzip':
            return zlib.gzip(body, sendResponse);
          default:
            return sendResponse(void 0, body);
        }
    }
  };

  handleRequest = function(request, response) {
    var dataflow;

    response.start = new Date();
    response.setHeader('X-Powered-By', "Node.js/" + process.version);
    response.setHeader('Server', "" + SERVER_NAME + "/" + SERVER_VERSION);
    response.setHeader('Cache-Control', 'no-cache, no-store');
    response.setHeader('Pragma', 'no-cache');
    response.setHeader('Content-Type', 'application/json');
    response.setHeader('Content-Language', 'en');
    response.statusCode = 200;
    response.result = {
      'sdmx-proto-json': dataset['sdmx-proto-json'],
      header: {
        id: "IREF" + (process.hrtime()[0]) + (process.hrtime()[1]),
        test: true,
        prepared: (new Date()).toISOString()
      },
      errors: []
    };
    validateRequest(request, response);
    if (response.statusCode === 200) {
      parse(request, response);
    }
    if (response.statusCode === 200) {
      dataflow = findDataFlow(request, response);
    }
    if (request.method === 'OPTIONS') {
      response.setHeader('Content-Length', 0);
    } else {
      if (response.statusCode === 200) {
        query(dataflow, request, response);
      }
      if (response.statusCode === 200) {
        response.result.header.name = dataset.header.name;
        response.result.errors = null;
      }
    }
    return compressResponse(request, response);
  };

  test = function() {
    var req, res;

    res = {
      headers: [],
      setHeader: function(n, v) {
        return this.headers[n] = v;
      },
      getHeader: function(n) {
        return this.headers[n];
      },
      end: function() {}
    };
    req = {
      method: 'GET',
      url: '/data/ECB_ICP1/M.PT.N.073000.4.INX?startPeriod=2009&endPeriod=2009',
      headers: {
        accept: 'application/json'
      }
    };
    handleRequest(req, res);
    return console.log(JSON.stringify(res.result, null, 2));
  };

  log('starting');

  dataset = loadDataset(DATA_FILE);

  http.createServer(handleRequest).listen(PORT_NUMBER);

  log("listening on port " + PORT_NUMBER);

}).call(this);
