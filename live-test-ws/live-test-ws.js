// Generated by CoffeeScript 1.3.3
(function() {
  var DATA_FILE, PORT_NUMBER, SERVER_NAME, SERVER_VERSION, addCodesToQuery, calculateIndexMultipliers, dataset, findDataFlow, findMatchingObsIndices, fs, handleRequest, http, loadDataset, log, parse, parseDataQuery, parseDate, parseFlowRef, parseKey, parseProviderRef, parseQueryParams, query, timePeriodToDate, url, validateRequest;

  http = require('http');

  url = require('url');

  fs = require('fs');

  SERVER_NAME = 'LIVE-TEST-WS';

  SERVER_VERSION = '0.1';

  PORT_NUMBER = process.env.PORT || 8081;

  DATA_FILE = 'hicp-coicop-inx.json';

  dataset = null;

  log = function(msg) {
    return console.log("" + (new Date().toTimeString().slice(0, 8)) + " " + msg);
  };

  calculateIndexMultipliers = function(dimensions) {
    var dim, i, multipliers, prev, reversedDimensions, _i, _len;
    multipliers = new Array(dimensions.length);
    reversedDimensions = dimensions.slice().reverse();
    prev = 1;
    for (i = _i = 0, _len = reversedDimensions.length; _i < _len; i = ++_i) {
      dim = reversedDimensions[i];
      multipliers[i] = prev;
      prev = dim.length * prev;
    }
    return multipliers.reverse();
  };

  loadDataset = function(filename) {
    var data, jsonString;
    jsonString = fs.readFileSync(filename);
    data = JSON.parse(jsonString);
    return data;
  };

  exports.timePeriodToDate = timePeriodToDate = function(frequency, year, period, end) {
    var date;
    if (year % 1 !== 0) {
      return null;
    }
    if (period % 1 !== 0) {
      return null;
    }
    if (period < 1) {
      return null;
    }
    date = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
    if (!end) {
      period = period - 1;
    }
    switch (frequency) {
      case 'A':
        if (1 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (12 * period));
        break;
      case 'S':
        if (2 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (6 * period));
        break;
      case 'T':
        if (3 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (4 * period));
        break;
      case 'Q':
        if (4 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + (3 * period));
        break;
      case 'M':
        if (12 < period) {
          return null;
        }
        date.setUTCMonth(date.getUTCMonth() + period);
        break;
      case 'W':
        if (53 < period) {
          return null;
        }
        if (date.getUTCDay() !== 4) {
          date.setUTCMonth(0, 1 + (((4 - date.getUTCDay()) + 7) % 7));
        }
        date.setUTCDate(date.getUTCDate() - 3);
        date.setUTCDate(date.getUTCDate() + (7 * period));
        break;
      case 'D':
        if (366 < period) {
          return null;
        }
        date.setUTCDate(date.getUTCDate() + period);
        break;
      default:
        return null;
    }
    return date;
  };

  exports.parseDate = parseDate = function(value, end) {
    var date, millisecs;
    date = null;
    if (/^\d\d\d\d-[A|S|T|Q]\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value[6], end);
    } else if (/^\d\d\d\d-[M|W]\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 8), end);
    } else if (/^\d\d\d\d-D\d\d\d$/.test(value)) {
      date = timePeriodToDate(value[5], +value.slice(0, 4), +value.slice(6, 9), end);
    } else {
      millisecs = Date.parse(value);
      if (isNaN(millisecs)) {
        return null;
      }
      date = new Date(millisecs);
      if (end) {
        switch (value.length) {
          case 4:
            date.setUTCFullYear(date.getUTCFullYear() + 1);
            break;
          case 7:
            date.setUTCMonth(date.getUTCMonth() + 1);
            break;
          case 10:
            date.setUTCDate(date.getUTCDate() + 1);
        }
      }
    }
    if ((date != null) && end) {
      date.setUTCSeconds(date.getUTCSeconds() - 1);
    }
    return date;
  };

  exports.parseFlowRef = parseFlowRef = function(flowRefStr, request, response) {
    var flowRef, regex;
    if (!(flowRefStr != null)) {
      response.result.error.push('Mandatory parameter flowRef is missing');
      response.statusCode = 400;
      return;
    }
    regex = /^(([A-z0-9_@$\-]+)|(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*)(\,[A-z0-9_@$\-]+)(\,(latest|([0-9]+(\.[0-9]+)*)))?))$/;
    if (!regex.test(flowRefStr)) {
      response.result.error.push("Invalid parameter flowRef " + flowRefStr);
      response.statusCode = 400;
      return;
    }
    flowRef = flowRefStr.split(',');
    if (flowRef.length === 1) {
      flowRef[1] = flowRef[0];
      flowRef[0] = 'all';
    }
    if (!(flowRef[2] != null) || flowRef[2] === '') {
      flowRef[2] = 'latest';
    }
    return request.query.flowRef = {
      agencyID: flowRef[0],
      id: flowRef[1],
      version: flowRef[2]
    };
  };

  exports.parseKey = parseKey = function(keyStr, request, response) {
    var code, codes, dim, dims, i, key, regex, _i, _j, _len, _len1;
    if (keyStr == null) {
      keyStr = 'all';
    }
    if (keyStr === 'all') {
      request.query.key = 'all';
      return;
    }
    regex = /^(([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?([.]([A-Za-z0-9_@$\-]+([+][A-Za-z0-9_@$\-]+)*)?)*)$/;
    if (!regex.test(keyStr)) {
      response.result.error.push("Invalid parameter flowRef " + keyStr);
      response.statusCode = 400;
      return;
    }
    key = [];
    dims = keyStr.split('.');
    for (i = _i = 0, _len = dims.length; _i < _len; i = ++_i) {
      dim = dims[i];
      codes = dim.split('+');
      key[i] = [];
      for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
        code = codes[_j];
        if (code !== '') {
          key[i].push(code);
        }
      }
      if (-1 < dim.indexOf('+') && key[i].length === 0) {
        response.result.error.push("Invalid parameter key " + keyStr);
        response.statusCode = 400;
        return;
      }
    }
    return request.query.key = key;
  };

  exports.parseProviderRef = parseProviderRef = function(providerRefStr, request, response) {
    var providerRef, regex;
    if (providerRefStr == null) {
      providerRefStr = 'all';
    }
    regex = /^(([A-z][A-z0-9_\-]*(\.[A-z][A-z0-9_\-]*)*\,)?([A-z0-9_@$\-]+))$/;
    if (!regex.test(providerRefStr)) {
      response.result.error.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = 400;
      return;
    }
    providerRef = providerRefStr.split(',');
    switch (providerRef.length) {
      case 1:
        if (providerRef[0] !== 'all') {
          providerRef[1] = providerRef[0];
          providerRef[0] = 'all';
        }
    }
    if (!(providerRef[0] != null) || providerRef[0] === '') {
      providerRef[0] = 'all';
    }
    if (!(providerRef[1] != null) || providerRef[1] === '') {
      providerRef[1] = 'all';
    }
    if (providerRef.length !== 2) {
      response.result.error.push("Invalid parameter providerRef " + providerRefStr);
      response.statusCode = 400;
      return;
    }
    return request.query.providerRef = {
      agencyID: providerRef[0],
      id: providerRef[1]
    };
  };

  exports.parseQueryParams = parseQueryParams = function(request, response) {
    var date, n, param, parameters, value;
    parameters = url.parse(request.url, true, false).query;
    for (param in parameters) {
      value = parameters[param];
      switch (param) {
        case 'startPeriod':
        case 'endPeriod':
          date = parseDate(value, param === 'endPeriod');
          if (date != null) {
            request.query[param] = date;
            continue;
          }
          break;
        case 'firstNObservations':
        case 'lastNObservations':
          n = ~Number(value);
          if (String(n) === value && n >= 0) {
            request.query[param] = n;
            continue;
          }
          break;
        case 'updatedAfter':
          response.statusCode = 501;
          return;
        case 'dimensionAtObservation':
          continue;
        case 'detail':
          switch (value) {
            case 'full':
            case 'dataonly':
            case 'nodata':
              request.query.detail = value;
              continue;
            case 'serieskeysonly':
              response.statusCode = 501;
              return;
          }
      }
      response.result.error.push("Invalid query parameter " + param + " value " + value);
      response.statusCode = 400;
      return;
    }
  };

  parseDataQuery = function(path, request, response) {
    parseFlowRef(path[2], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseKey(path[3], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseProviderRef(path[4], request, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseQueryParams(request, response);
    if (response.statusCode !== 200) {

    }
  };

  parse = function(request, response) {
    var path;
    request.query = {};
    path = url.parse(request.url, false, false).pathname.split('/');
    request.query.resource = path[1];
    switch (request.query.resource) {
      case 'data':
        return parseDataQuery(path, request, response);
      default:
        response.statusCode = 501;
    }
  };

  findDataFlow = function(request, response) {
    var found;
    found = true;
    found &= (function() {
      switch (request.query.flowRef.agencyID) {
        case 'all':
        case 'ECB':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.id) {
        case 'ECB_ICP1':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.flowRef.version) {
        case 'latest':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.agencyID) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    found &= (function() {
      switch (request.query.providerRef.id) {
        case 'ECB':
        case 'all':
          return true;
        default:
          return false;
      }
    })();
    if (!found) {
      response.statusCode = 404;
      response.result.error.push("Data flow not found");
      return;
    }
    return dataset;
  };

  addCodesToQuery = function(request, response, msg) {
    var code, dim, endDate, i, index, j, keyCodes, period, query, startDate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    query = [];
    _ref = msg.dimension.id;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      dim = _ref[i];
      query[i] = [];
    }
    _ref1 = msg.dimension.id;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      dim = _ref1[i];
      if (msg.dimension[dim].role !== 'time') {
        continue;
      }
      _ref2 = msg.dimension[dim].code.id;
      for (j = _k = 0, _len2 = _ref2.length; _k < _len2; j = ++_k) {
        period = _ref2[j];
        if (request.query.startPeriod != null) {
          startDate = parseDate(period, false);
          if (!(request.query.startPeriod <= startDate)) {
            continue;
          }
        }
        if (request.query.endPeriod != null) {
          endDate = parseDate(period, true);
          if (!(endDate <= request.query.endPeriod)) {
            continue;
          }
        }
        query[i].push(j);
      }
      break;
    }
    if (request.query.key === 'all') {
      _ref3 = msg.dimension.id;
      for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
        dim = _ref3[i];
        if (msg.dimension[dim].role === 'time') {
          continue;
        }
        _ref4 = msg.dimension[dim].code.id;
        for (j = _m = 0, _len4 = _ref4.length; _m < _len4; j = ++_m) {
          code = _ref4[j];
          query[i].push(j);
        }
      }
      return;
    }
    if (request.query.key.length !== msg.dimension.id.length - 1) {
      response.result.error.push("Invalid number of dimensions in parameter key");
      response.statusCode = 400;
      return;
    }
    _ref5 = request.query.key;
    for (i = _n = 0, _len5 = _ref5.length; _n < _len5; i = ++_n) {
      keyCodes = _ref5[i];
      dim = msg.dimension.id[i];
      if (keyCodes.length === 0) {
        _ref6 = msg.dimension[dim].code.id;
        for (j = _o = 0, _len6 = _ref6.length; _o < _len6; j = ++_o) {
          code = _ref6[j];
          query[i].push(j);
        }
        continue;
      }
      for (_p = 0, _len7 = keyCodes.length; _p < _len7; _p++) {
        code = keyCodes[_p];
        index = msg.dimension[dim].code.index[code];
        if (0 <= index) {
          query[i].push(index);
        }
      }
    }
    return query;
  };

  findMatchingObsIndices = function(key, keyPosition, query, msg, result) {
    var codeIndex, dim, i, index, j, obsCount, prev, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    if (keyPosition === query.length - 1) {
      obsCount = 0;
      _ref = query[keyPosition];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        codeIndex = _ref[i];
        key[keyPosition] = codeIndex;
        index = 0;
        prev = 1;
        for (j = _j = _ref1 = msg.dimension.id.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; j = _ref1 <= 0 ? ++_j : --_j) {
          dim = msg.dimension.id[j];
          index += key[j] * prev;
          prev *= msg.dimension[dim].code.size;
        }
        if (msg.measure[msg.measure.id[0]].value[index] != null) {
          for (j = _k = 0, _len1 = key.length; _k < _len1; j = ++_k) {
            codeIndex = key[j];
            result.codeIndices[j][codeIndex] = 1;
          }
          result.obsIndices.push(index);
          obsCount += 1;
        }
      }
      return;
    }
    _ref2 = query[keyPosition];
    _results = [];
    for (i = _l = 0, _len2 = _ref2.length; _l < _len2; i = ++_l) {
      codeIndex = _ref2[i];
      key[keyPosition] = codeIndex;
      _results.push(findMatchingObsIndices(key, keyPosition + 1, query, msg, result));
    }
    return _results;
  };

  query = function(msg, request, response) {
    var attr, attrCount, attrIndex, attrMultipliers, code, codeIndex, codeIndexMapping, codes, codesInQuery, codesWithData, dim, dimPos, firstResult, i, index, indices, j, key, keyCount, measure, msgMultipliers, msr, mult, multiplier, n, newIndex, obsCount, obsIndex, pos, queryMultipliers, remainder, resultCount, resultMultipliers, rslt, sourceMultiplier, sourceMultipliers, targetMultiplier, targetMultipliers, value, _aa, _ab, _ac, _ad, _ae, _af, _ag, _ah, _ai, _aj, _ak, _al, _base, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len18, _len19, _len2, _len20, _len21, _len22, _len23, _len24, _len25, _len26, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _s, _t, _u, _v, _w, _x, _y, _z;
    rslt = response.result;
    codesInQuery = addCodesToQuery(request, response, msg);
    obsCount = 1;
    msgMultipliers = [];
    _ref = msg.dimension.id;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dim = _ref[_i];
      msgMultipliers.push(obsCount);
      obsCount *= msg.dimension[dim].code.size;
    }
    msgMultipliers.reverse();
    keyCount = 1;
    queryMultipliers = [];
    codesWithData = [];
    for (_j = 0, _len1 = codesInQuery.length; _j < _len1; _j++) {
      codes = codesInQuery[_j];
      queryMultipliers.push(keyCount);
      keyCount *= codes.length;
      codesWithData.push({});
    }
    if (keyCount === 0) {
      response.statusCode = 404;
      response.result.error.push('Observations not found');
      return;
    }
    for (i = _k = 0, _ref1 = keyCount - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      key = [];
      for (n = _l = 0, _len2 = codesInQuery.length; _l < _len2; n = ++_l) {
        codes = codesInQuery[n];
        index = Math.floor(i / queryMultipliers[n]) % codes.length;
        key.push(codes[index]);
      }
      obsIndex = 0;
      for (j = _m = 0, _len3 = key.length; _m < _len3; j = ++_m) {
        pos = key[j];
        obsIndex += pos * msgMultipliers[j];
      }
      if (msg.measure['OBS_VALUE'].value[obsIndex] == null) {
        continue;
      }
      for (j = _n = 0, _len4 = key.length; _n < _len4; j = ++_n) {
        pos = key[j];
        if ((_ref2 = (_base = codesWithData[j])[pos]) == null) {
          _base[pos] = 0;
        }
        codesWithData[j][pos] += 1;
      }
    }
    rslt.dimension = {};
    rslt.dimension.id = msg.dimension.id;
    rslt.dimension.size = msg.dimension.id.length;
    _ref3 = msg.dimension.id;
    for (i = _o = 0, _len5 = _ref3.length; _o < _len5; i = ++_o) {
      dim = _ref3[i];
      rslt.dimension[dim] = {
        code: {
          id: [],
          index: {},
          name: {}
        },
        name: msg.dimension[dim].name,
        role: msg.dimension[dim].role
      };
      _ref4 = Object.keys(codesWithData[i]).sort();
      for (j = _p = 0, _len6 = _ref4.length; _p < _len6; j = ++_p) {
        pos = _ref4[j];
        code = msg.dimension[dim].code.id[pos];
        rslt.dimension[dim].code.id.push(code);
        rslt.dimension[dim].code.index[code] = j;
        rslt.dimension[dim].code.name[code] = msg.dimension[dim].code.name[code];
      }
      rslt.dimension[dim].code.size = rslt.dimension[dim].code.id.length;
    }
    resultCount = 1;
    resultMultipliers = [];
    _ref5 = rslt.dimension.id.slice().reverse();
    for (_q = 0, _len7 = _ref5.length; _q < _len7; _q++) {
      dim = _ref5[_q];
      resultMultipliers.push(resultCount);
      resultCount *= rslt.dimension[dim].code.size;
    }
    resultMultipliers.reverse();
    rslt.measure = {
      id: []
    };
    _ref6 = msg.measure.id;
    for (_r = 0, _len8 = _ref6.length; _r < _len8; _r++) {
      msr = _ref6[_r];
      rslt.measure.id.push(msr);
      rslt.measure[msr] = {
        size: resultCount,
        value: [],
        name: msg.measure[msr].name
      };
      for (i = _s = 0, _ref7 = resultCount - 1; 0 <= _ref7 ? _s <= _ref7 : _s >= _ref7; i = 0 <= _ref7 ? ++_s : --_s) {
        key = [];
        _ref8 = rslt.dimension.id;
        for (n = _t = 0, _len9 = _ref8.length; _t < _len9; n = ++_t) {
          dim = _ref8[n];
          index = Math.floor(i / resultMultipliers[n]) % rslt.dimension[dim].code.size;
          code = rslt.dimension[dim].code.id[index];
          key.push(msg.dimension[dim].code.index[code]);
        }
        obsIndex = 0;
        for (j = _u = 0, _len10 = key.length; _u < _len10; j = ++_u) {
          pos = key[j];
          obsIndex += pos * msgMultipliers[j];
        }
        rslt.measure[msr].value[i] = msg.measure[msr].value[obsIndex];
      }
    }
    _ref9 = msg.attribute.id;
    for (_v = 0, _len11 = _ref9.length; _v < _len11; _v++) {
      attr = _ref9[_v];
      if (msg.attribute[attr].dimension.length === rslt.dimension.size) {
        attrMultipliers = resultMultipliers;
        attrCount = resultCount;
      } else {
        continue;
      }
      value = [];
      for (i = _w = 0, _ref10 = attrCount - 1; 0 <= _ref10 ? _w <= _ref10 : _w >= _ref10; i = 0 <= _ref10 ? ++_w : --_w) {
        key = [];
        _ref11 = msg.attribute[attr].dimension;
        for (n = _x = 0, _len12 = _ref11.length; _x < _len12; n = ++_x) {
          dim = _ref11[n];
          index = Math.floor(i / resultMultipliers[n]) % rslt.dimension[dim].code.size;
          code = rslt.dimension[dim].code.id[index];
          key.push(msg.dimension[dim].code.index[code]);
        }
        attrIndex = 0;
        for (j = _y = 0, _len13 = key.length; _y < _len13; j = ++_y) {
          pos = key[j];
          attrIndex += pos * msgMultipliers[j];
        }
        if (msg.attribute[attr].value[attrIndex] == null) {
          continue;
        }
        value[i] = msg.attribute[attr].value[attrIndex];
      }
      if (value.length === 0 && msg.attribute[attr]["default"] === null) {
        continue;
      }
      if ((_ref12 = rslt.attribute) == null) {
        rslt.attribute = {
          id: []
        };
      }
      rslt.attribute.id.push(attr);
      rslt.attribute[attr] = {
        name: msg.attribute[attr].name,
        mandatory: msg.attribute[attr].mandatory,
        role: msg.attribute[attr].role,
        dimension: msg.attribute[attr].dimension,
        "default": msg.attribute[attr]["default"],
        value: value
      };
    }
    return;
    firstResult = {
      codeIndices: [],
      obsIndices: []
    };
    for (_z = 0, _len14 = codesInQuery.length; _z < _len14; _z++) {
      dim = codesInQuery[_z];
      firstResult.codeIndices.push({});
    }
    findMatchingObsIndices([], 0, codesInQuery, msg, firstResult);
    if (firstResult.obsIndices.length === 0) {
      response.statusCode = 404;
      response.result.error.push('Observations not found');
      return;
    }
    codeIndexMapping = [];
    response.result.dimension = {};
    response.result.dimension.id = msg.dimension.id;
    response.result.dimension.size = msg.dimension.id.length;
    _ref13 = msg.dimension.id;
    for (i = _aa = 0, _len15 = _ref13.length; _aa < _len15; i = ++_aa) {
      dim = _ref13[i];
      response.result.dimension[dim] = {
        code: {
          id: [],
          index: {},
          name: {}
        },
        name: msg.dimension[dim].name,
        role: msg.dimension[dim].role
      };
      indices = firstResult.codeIndices[i];
      codeIndexMapping[i] = [];
      _ref14 = Object.keys(indices).sort();
      for (j = _ab = 0, _len16 = _ref14.length; _ab < _len16; j = ++_ab) {
        codeIndex = _ref14[j];
        codeIndexMapping[i][codeIndex] = j;
        code = msg.dimension[dim].code.id[codeIndex];
        response.result.dimension[dim].code.id[j] = code;
        response.result.dimension[dim].code.index[code] = j;
        response.result.dimension[dim].code.name[code] = msg.dimension[dim].code.name[code];
      }
      response.result.dimension[dim].code.size = response.result.dimension[dim].code.id.length;
      if (msg.dimension[dim].role === 'time') {
        response.result.dimension[dim].code.startDate = {};
        response.result.dimension[dim].code.endDate = {};
        _ref15 = response.result.dimension[dim].code.id;
        for (j = _ac = 0, _len17 = _ref15.length; _ac < _len17; j = ++_ac) {
          code = _ref15[j];
          response.result.dimension[dim].code.startDate[code] = parseDate(code, false);
          response.result.dimension[dim].code.endDate[code] = parseDate(code, true);
        }
      }
    }
    if (request.query.detail === 'nodata') {
      return;
    }
    sourceMultipliers = [];
    sourceMultiplier = 1;
    targetMultipliers = [];
    targetMultiplier = 1;
    _ref16 = msg.dimension.id.slice().reverse();
    for (_ad = 0, _len18 = _ref16.length; _ad < _len18; _ad++) {
      dim = _ref16[_ad];
      sourceMultipliers.push(sourceMultiplier);
      targetMultipliers.push(targetMultiplier);
      sourceMultiplier *= msg.dimension[dim].code.size;
      targetMultiplier *= response.result.dimension[dim].code.size;
    }
    sourceMultipliers.reverse();
    targetMultipliers.reverse();
    response.result.measure = {
      id: msg.measure.id
    };
    _ref17 = msg.measure.id;
    for (_ae = 0, _len19 = _ref17.length; _ae < _len19; _ae++) {
      measure = _ref17[_ae];
      response.result.measure[measure] = {
        value: []
      };
      _ref18 = firstResult.obsIndices;
      for (_af = 0, _len20 = _ref18.length; _af < _len20; _af++) {
        index = _ref18[_af];
        newIndex = 0;
        remainder = index;
        for (i = _ag = 0, _len21 = sourceMultipliers.length; _ag < _len21; i = ++_ag) {
          mult = sourceMultipliers[i];
          codeIndex = Math.floor(remainder / mult);
          remainder = remainder - (codeIndex * mult);
          newIndex += codeIndexMapping[i][codeIndex] * targetMultipliers[i];
        }
        response.result.measure[measure].value[newIndex] = msg.measure[measure].value[index];
      }
    }
    response.result.measure.size = 1;
    _ref19 = response.result.dimension.id;
    for (_ah = 0, _len22 = _ref19.length; _ah < _len22; _ah++) {
      dim = _ref19[_ah];
      response.result.measure.size *= response.result.dimension[dim].code.size;
    }
    key = [];
    _ref20 = response.result.dimension.id;
    for (_ai = 0, _len23 = _ref20.length; _ai < _len23; _ai++) {
      dim = _ref20[_ai];
      key.push(response.result.dimension[dim].code.id[0]);
    }
    console.log(key);
    response.result.attribute = {
      id: []
    };
    _ref21 = msg.attribute.id;
    _results = [];
    for (_aj = 0, _len24 = _ref21.length; _aj < _len24; _aj++) {
      attr = _ref21[_aj];
      response.result.attribute.id.push(attr);
      response.result.attribute[attr] = {
        name: msg.attribute[attr].name,
        mandatory: msg.attribute[attr].mandatory,
        role: msg.attribute[attr].role,
        dimension: msg.attribute[attr].dimension,
        "default": msg.attribute[attr]["default"],
        value: []
      };
      index = 0;
      multiplier = 1;
      _ref22 = msg.attribute[attr].dimension.slice().reverse();
      for (j = _ak = 0, _len25 = _ref22.length; _ak < _len25; j = ++_ak) {
        dim = _ref22[j];
        dimPos = msg.dimension.id.indexOf(dim);
        index += msg.dimension[dim].code.index[key[dimPos]] * multiplier;
        multiplier *= msg.dimension[dim].code.size;
      }
      value = msg.attribute[attr].value[index];
      if (value == null) {
        continue;
      }
      index = 0;
      multiplier = 1;
      _ref23 = response.result.attribute[attr].dimension.slice().reverse();
      for (j = _al = 0, _len26 = _ref23.length; _al < _len26; j = ++_al) {
        dim = _ref23[j];
        dimPos = response.result.dimension.id.indexOf(dim);
        index += response.result.dimension[dim].code.index[key[dimPos]] * multiplier;
        multiplier *= response.result.dimension[dim].code.size;
      }
      _results.push(response.result.attribute[attr].value[index] = value);
    }
    return _results;
  };

  validateRequest = function(request, response) {
    var matches, mediaTypes, methods, type, _i, _len;
    methods = ['GET', 'HEAD'];
    mediaTypes = ['application/json', 'application/*', '*/*'];
    if (methods.indexOf(request.method) === -1) {
      response.statusCode = 405;
      response.setHeader('Allow', methods.join(','));
      response.result.error.push('Supported methods: ' + methods.join(','));
      return;
    }
    if (request.headers['accept'] != null) {
      matches = 0;
      for (_i = 0, _len = mediaTypes.length; _i < _len; _i++) {
        type = mediaTypes[_i];
        matches += request.headers['accept'].indexOf(type) + 1;
      }
      if (matches === 0) {
        response.statusCode = 406;
        response.result.error.push('Supported media types: ' + mediaTypes.join(','));
      }
    }
  };

  handleRequest = function(request, response) {
    var body, dataflow, start;
    start = new Date();
    response.setHeader('X-Powered-By', "Node.js/" + process.version);
    response.setHeader('Server', "" + SERVER_NAME + "/" + SERVER_VERSION);
    response.setHeader('Cache-Control', 'no-cache, no-store');
    response.setHeader('Pragma', 'no-cache');
    response.setHeader('Access-Control-Allow-Origin', '*');
    response.setHeader('Content-Type', 'application/json');
    response.statusCode = 200;
    response.result = {
      id: "IREF" + (process.hrtime()[0]) + (process.hrtime()[1]),
      test: true,
      prepared: (new Date()).toISOString(),
      error: []
    };
    validateRequest(request, response);
    if (response.statusCode === 200) {
      parse(request, response);
    }
    if (response.statusCode === 200) {
      dataflow = findDataFlow(request, response);
    }
    if (response.statusCode === 200) {
      query(dataflow, request, response);
    }
    if (response.statusCode === 200) {
      response.result.name = dataset.name;
      response.result.error = null;
    }
    body = JSON.stringify(response.result, null, 2);
    response.setHeader('Content-Length', Buffer.byteLength(body));
    response.setHeader('X-Runtime', new Date() - start);
    if (request.method === 'GET') {
      response.end(body);
    } else {
      response.end();
    }
    return log("" + request.method + " " + request.url + " " + response.statusCode);
  };

  log('starting');

  dataset = loadDataset(DATA_FILE);

  http.createServer(handleRequest).listen(PORT_NUMBER);

  log("listening on port " + PORT_NUMBER);

}).call(this);
