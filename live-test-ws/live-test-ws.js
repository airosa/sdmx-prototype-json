// Generated by CoffeeScript 1.3.3
(function() {
  var DATA_FILE, PORT_NUMBER, calculateIndexMultipliers, dataset, findMatchingObsIndices, fs, handleRequest, http, loadDataset, log, parseDate, parseFlowRef, parseKey, parseProviderRef, parseQueryParameters, parseReportingTimePeriod, parseUrl, queryData, url;

  http = require('http');

  url = require('url');

  fs = require('fs');

  PORT_NUMBER = 8081;

  DATA_FILE = 'hicp-coicop-inx.json';

  dataset = null;

  log = function(msg) {
    return console.log("" + (new Date().toTimeString().slice(0, 8)) + " " + msg);
  };

  calculateIndexMultipliers = function(dimensions) {
    var dim, i, multipliers, prev, reversedDimensions, _i, _len;
    multipliers = new Array(dimensions.length);
    reversedDimensions = dimensions.slice().reverse();
    prev = 1;
    for (i = _i = 0, _len = reversedDimensions.length; _i < _len; i = ++_i) {
      dim = reversedDimensions[i];
      multipliers[i] = prev;
      prev = dim.length * prev;
    }
    return multipliers.reverse();
  };

  loadDataset = function(filename) {
    var data, jsonString;
    jsonString = fs.readFileSync(filename);
    data = JSON.parse(jsonString);
    data.indexMultipliers = calculateIndexMultipliers(data.codes);
    return data;
  };

  parseReportingTimePeriod = function(frequency, year, period, end) {
    var date;
    if (year % 1 !== 0) {
      throw new Error("Invalid year value " + year);
    }
    if (period % 1 !== 0) {
      throw new Error("Invalid period value " + period);
    }
    date = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
    if (!end) {
      period = period - 1;
    }
    switch (frequency) {
      case 'A':
        date;

        break;
      case 'S':
        if (0 < period && period < 3) {
          date.setUTCMonth(date.getUTCMonth() + (6 * period));
        } else {
          throw new Error("Invalid period value " + period);
        }
        break;
      case 'T':
        if (0 < period && period < 4) {
          date.setUTCMonth(date.getUTCMonth() + (4 * period));
        } else {
          throw new Error("Invalid period value " + period);
        }
        break;
      case 'Q':
        if (0 < period && period < 5) {
          date.setUTCMonth(date.getUTCMonth() + (3 * period));
        } else {
          throw new Error("Invalid period value " + period);
        }
        break;
      case 'M':
        if (0 < period && period < 13) {
          date.setUTCMonth(date.getUTCMonth() + period);
        } else {
          throw new Error("Invalid period value " + period);
        }
        break;
      case 'W':
        if (date.getUTCDay() !== 4) {
          date.setUTCMonth(0, 1 + (((4 - date.getUTCDay()) + 7) % 7));
        }
        date.setUTCDate(date.getUTCDate() - 3);
        date.setUTCDate(date.getUTCDate() + (7 * period));
        break;
      case 'D':
        date.setUTCDate(date.getUTCDate() + period);
    }
    return date;
  };

  parseDate = function(value, end) {
    var date;
    date = null;
    try {
      switch (value.length) {
        case 4:
          date = new Date(Date.UTC(+value, 0, 1, 0, 0, 0));
          if (end) {
            date.setUTCFullYear(date.getUTCFullYear() + 1);
          }
          break;
        case 7:
          switch (value.slice(5, 6)) {
            case 'A':
            case 'S':
            case 'T':
            case 'Q':
              date = parseReportingTimePeriod(value.slice(5, 6), +value.slice(0, 4), +value.slice(6), end);
              break;
            default:
              date = new Date(Date.UTC(+value.slice(0, 4), +value.slice(5, 7) - 1, 1, 0, 0, 0));
              if (end) {
                date.setUTCMonth(date.getUTCMonth() + 1);
              }
          }
          break;
        case 8:
        case 9:
          date = parseReportingTimePeriod(value.slice(5, 6), +value.slice(0, 4), +value.slice(6), end);
          break;
        case 10:
          date = new Date(Date.UTC(+value.slice(0, 4), +value.slice(5, 7) - 1, +value.slice(8, 10), 0, 0, 0));
          if (end) {
            date.setUTCDate(date.getUTCDate() + 1);
          }
          break;
        case 19:
          return Date.parse(value, 'yyyy-MM-ddTHH:mm:ss');
      }
      if (end) {
        date.setUTCSeconds(date.getUTCSeconds() - 1);
      }
    } catch (error) {
      date = null;
    }
    return date;
  };

  parseFlowRef = function(flowRefStr, dataQuery, response) {
    var flowRef, flowRefOk;
    if (!(flowRefStr != null)) {
      response.setHeader('Warning', '199 Mandatory parameter flowRef is missing');
      response.statusCode = 400;
      return;
    }
    flowRef = flowRefStr.split(',');
    switch (flowRef.length) {
      case 1:
        flowRef[1] = flowRef[0];
        flowRef[0] = 'ALL';
        flowRef[2] = 'LATEST';
        break;
      case 2:
        flowRef[2] = 'LATEST';
    }
    flowRefOk = flowRef[0] === 'ALL' || flowRef[0] === 'ECB';
    flowRefOk = flowRefOk && flowRef[1] === 'ECB_ICP1';
    flowRefOk = flowRefOk && flowRef[2] === 'LATEST';
    flowRefOk = flowRefOk && flowRef.length === 3;
    if (!flowRefOk) {
      response.setHeader('Warning', "199 Invalid parameter flowRef " + flowRefStr);
      response.statusCode = 400;
    }
  };

  parseKey = function(keyStr, dataQuery, dataset, response) {
    var code, codes, i, index, j, key, keys, _i, _j, _len, _ref, _results, _results1;
    dataQuery.codes = [];
    if (keyStr != null) {
      keys = keyStr.split('.');
      if (keys.length !== dataset.codes.length - 1) {
        response.setHeader('Warning', "199 Invalid number of dimensions in parameter key");
        response.statusCode = 400;
        return;
      }
      _results = [];
      for (i = _i = 0, _len = keys.length; _i < _len; i = ++_i) {
        key = keys[i];
        codes = key.split('+');
        dataQuery.codes[i] = [];
        if (codes.length === 1 && codes[0].length === 0) {
          _results.push((function() {
            var _j, _len1, _ref, _results1;
            _ref = dataset.codes[i];
            _results1 = [];
            for (j = _j = 0, _len1 = _ref.length; _j < _len1; j = ++_j) {
              code = _ref[j];
              _results1.push(dataQuery.codes[i].push(j));
            }
            return _results1;
          })());
        } else {
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
              code = codes[_j];
              index = dataset.codes[i].indexOf(code);
              if (0 <= index) {
                _results1.push(dataQuery.codes[i].push(index));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
      }
      return _results;
    } else {
      _results1 = [];
      for (i = _j = 0, _ref = dataset.codes.length - 2; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        dataQuery.codes[i] = [];
        _results1.push((function() {
          var _k, _ref1, _results2;
          _results2 = [];
          for (j = _k = 0, _ref1 = dataset.codes[i].length - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
            _results2.push(dataQuery.codes[i].push(j));
          }
          return _results2;
        })());
      }
      return _results1;
    }
  };

  parseProviderRef = function(providerRefStr, dataQuery, response) {
    var providerRef, providerRefOk;
    if (providerRefStr != null) {
      providerRef = providerRefStr.split(',');
      switch (providerRef.length) {
        case 1:
          if (providerRef[0] === 'all') {
            providerRef[1] = 'ALL';
          } else {
            providerRef[1] = providerRef[0];
          }
          providerRef[0] = 'ALL';
      }
      providerRefOk = providerRef.length === 1;
      providerRefOk = providerRefOk && providerRef[0] === 'ECB' || providerRef[0] === 'ALL';
      providerRefOk = providerRef[1] === 'ECB' || providerRef[1] === 'ALL';
      if (!providerRefOk) {
        response.setHeader('Warning', "199 Invalid parameter providerRef " + providerRefStr);
        response.statusCode = 400;
      }
    }
  };

  parseQueryParameters = function(parameters, dataQuery, dataset, response) {
    var date, endDate, i, n, param, period, periods, startDate, value, _i, _j, _len, _len1, _ref, _ref1;
    for (param in parameters) {
      value = parameters[param];
      switch (param) {
        case 'startPeriod':
        case 'endPeriod':
          date = parseDate(value, param === 'endPeriod');
          if (date != null) {
            dataQuery[param] = date;
            continue;
          }
          break;
        case 'firstNObservations':
        case 'lastNObservations':
          n = ~Number(value);
          if (String(n) === value && n >= 0) {
            dataQuery[param] = n;
            continue;
          }
          break;
        case 'updatedAfter':
          response.statusCode = 501;
          return;
        case 'dimensionAtObservation':
          continue;
        case 'detail':
          switch (value) {
            case 'full':
            case 'dataonly':
            case 'nodata':
              dataQuery.detail = value;
              continue;
            case 'serieskeysonly':
              response.statusCode = 501;
              return;
          }
      }
      response.setHeader('Warning', "199 Invalid query parameter " + param + " value " + value);
      response.statusCode = 400;
      return;
    }
    periods = [];
    if ((dataQuery.startPeriod != null) || (dataQuery.endPeriod != null)) {
      _ref = dataset.codes[dataset.codes.length - 1];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        period = _ref[i];
        startDate = parseDate(period, false);
        endDate = parseDate(period, true);
        if (dataQuery.startPeriod != null) {
          if (!(dataQuery.startPeriod <= startDate)) {
            continue;
          }
        }
        if (dataQuery.endPeriod != null) {
          if (!(endDate <= dataQuery.endPeriod)) {
            continue;
          }
        }
        periods.push(i);
      }
    } else {
      _ref1 = dataset.codes[dataset.codes.length - 1];
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        period = _ref1[i];
        periods.push(i);
      }
    }
    return dataQuery.codes.push(periods);
  };

  parseUrl = function(requestUrl, response) {
    var dataQuery, parsedUrl, path;
    dataQuery = {};
    parsedUrl = url.parse(requestUrl, true);
    path = parsedUrl.pathname.split('/');
    if (path[1] !== 'data') {
      response.statusCode = 501;
      return;
    }
    parseFlowRef(path[2], dataQuery, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseKey(path[3], dataQuery, dataset, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseProviderRef(path[4], dataQuery, response);
    if (response.statusCode !== 200) {
      return;
    }
    parseQueryParameters(parsedUrl.query, dataQuery, dataset, response);
    if (response.statusCode !== 200) {
      return;
    }
    return dataQuery;
  };

  findMatchingObsIndices = function(key, keyPosition, queryResult, query, dataset) {
    var codeIndex, i, index, j, multiplier, obsCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
    if (keyPosition === query.length - 1) {
      obsCount = 0;
      _ref = query[keyPosition];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        codeIndex = _ref[i];
        key[keyPosition] = codeIndex;
        index = 0;
        _ref1 = dataset.indexMultipliers;
        for (j = _j = 0, _len1 = _ref1.length; _j < _len1; j = ++_j) {
          multiplier = _ref1[j];
          index += key[j] * multiplier;
        }
        if (dataset.data[index] != null) {
          for (j = _k = 0, _len2 = key.length; _k < _len2; j = ++_k) {
            codeIndex = key[j];
            queryResult.codes[j][codeIndex] = 1;
          }
          queryResult.obsIndices.push(index);
          obsCount += 1;
        }
      }
      return;
    }
    _ref2 = query[keyPosition];
    _results = [];
    for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
      codeIndex = _ref2[i];
      key[keyPosition] = codeIndex;
      _results.push(findMatchingObsIndices(key, keyPosition + 1, queryResult, query, dataset));
    }
    return _results;
  };

  queryData = function(query, response) {
    var codeIndex, codeIndexMapping, dim, i, index, j, mult, newIndex, queryResult, queryTmpResult, remainder, resultIndexMultipliers, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    queryTmpResult = {
      codes: [],
      obsIndices: []
    };
    _ref = dataset.codes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dim = _ref[_i];
      queryTmpResult.codes.push({});
    }
    findMatchingObsIndices([], 0, queryTmpResult, query.codes, dataset);
    queryResult = {
      codes: [],
      data: []
    };
    codeIndexMapping = [];
    _ref1 = queryTmpResult.codes;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      dim = _ref1[i];
      queryResult.codes[i] = [];
      codeIndexMapping[i] = [];
      _ref2 = Object.keys(dim).sort();
      for (j = _k = 0, _len2 = _ref2.length; _k < _len2; j = ++_k) {
        codeIndex = _ref2[j];
        codeIndexMapping[i][codeIndex] = j;
        queryResult.codes[i][j] = dataset.codes[i][codeIndex];
      }
    }
    resultIndexMultipliers = calculateIndexMultipliers(queryResult.codes);
    _ref3 = queryTmpResult.obsIndices;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      index = _ref3[_l];
      newIndex = 0;
      remainder = index;
      _ref4 = dataset.indexMultipliers;
      for (i = _m = 0, _len4 = _ref4.length; _m < _len4; i = ++_m) {
        mult = _ref4[i];
        codeIndex = Math.floor(remainder / mult);
        remainder = remainder - (codeIndex * mult);
        newIndex += codeIndexMapping[i][codeIndex] * resultIndexMultipliers[i];
      }
      queryResult.data[newIndex] = dataset.data[index];
    }
    if (query.detail === 'nodata') {
      delete queryResult.data;
    }
    return queryResult;
  };

  handleRequest = function(request, response) {
    var data, dataQuery;
    log("request " + request.url + " from " + request.connection.remoteAddress);
    response.setHeader('Server', 'SDMX-PROTOTYPE-JSON-TEST/0.1');
    response.setHeader('Cache-Control', 'no-cache, no-store');
    response.setHeader('Pragma', 'no-cache');
    response.setHeader('Access-Control-Allow-Origin', '*');
    response.statusCode = 200;
    if (!(request.method === 'GET' || request.method === 'HEAD')) {
      response.statusCode = 405;
      response.setHeader('Allow', 'GET, HEAD');
      response.end();
      return;
    }
    dataQuery = parseUrl(request.url, response);
    if (response.statusCode !== 200) {
      response.end();
      return;
    }
    data = queryData(dataQuery, response);
    if (response.statusCode !== 200) {
      response.end();
      return;
    }
    response.setHeader('Content-Type', 'application/json');
    if (request.method === 'GET') {
      response.end(JSON.stringify(data, null, 2));
    } else {
      response.end();
    }
    return log("response " + response.statusCode);
  };

  log('starting');

  dataset = loadDataset(DATA_FILE);

  http.createServer(handleRequest).listen(PORT_NUMBER);

  log("listening on port " + PORT_NUMBER);

}).call(this);
